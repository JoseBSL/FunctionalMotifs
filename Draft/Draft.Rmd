---
title: Plant-pollintor networks worldwide are composed by the same specific building
  blocks
output:
  html_document: default
  pdf_document: default
editor_options:
  chunk_output_type: console
bibliography: bibliography.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

##Abstract

Ecological processes leave distinct structural imprints on indirect interactions in mutualistic networks. Detecting those relationships is not trivial since they go beyond pair-wise interactions, but may get blurred when considering full network descriptors. However, recent work has shown the network meso-scale can capture this important information. The meso-scale describes network subgraphs representing patterns of interactions between a small number of species (i.e. motifs) and those constitute the building blocks of the whole network. Here we have compiled 60 networks from 18 different studies and show that some motifs are consitently over-represented worldwide, suggesting that the building blocks of plant-pollintor networks are not random and are associated to ... Second, we show that the position of pollinator guilds and plant reproductive strategies is not random with respect to the positions occupied within each motif. ... Hence, we show that species ecology is shaping the building blocks that conform the web of life.

##INTRODUCTION

The interaction between plants and pollinators can be studied at different scales, from species level interactions (micro-scale) to the full network structure (macro-scale). However, condensing to species level and the holistic view of the full network involves missing relevant information for the understanding of ecological processes [@delmas2019; @simmons2019]. Intermediate levels that investigate plant-pollinator networks (meso-scale) have been little explored but can shed light on ecological processes not captured by the traditional approaches used in plant-pollinator network studies. 


Research of plant-pollinator networks have proven common invariant structural properties across networks. Mutualistic networks tend to be nested [@bascompte2003], the degree distribution (number of links per species) generally follows a truncated power law distribution [@jordano2003] and there is an imbalance with approximately four times more pollinator species than plant species [@vazquez2009]. In addition, phenological overlap, morphological matching and species abundances have been shown to be determinant for the understanding of plant-pollinator interactions and network structure [@stang2006; @peralta2020]. Despite progress in plant-pollinator interactions, indirect interactions such as the competitive and facilitative interactions between plants for pollinators have been rarely investigated [@simmons2020]. However, the recent advances in analytical tools [..To be continued..]




Trait matching

[Explain what macro-descriptors have found i.e. Bascompte, and what pairwise interactions descriptors have accomplished i.e. trait-matching. End explaining Benno simmons work]


Exploring the different and most frequent motifs could help our understanding of species interactions due to motifs consider direct and indirect interactions not accounted in single species metrics. [Explain this: https://besjournals.onlinelibrary.wiley.com/doi/full/10.1111/1365-2435.13736 and say we don't know how motif distribution really looks like in the real world. Which is the expected pattern?]

However, motifs are abstract representations often decoupled from species ecology. [explain here the importance of relating reproductive strategies and pollinators behaviours to their positions within a motif. This is interesting because bridges pairwise interactions to the emergent network via motifs] 

Here, we used ... blah... and fined plant functional groups by using a comprehensive dataset with several reproductive traits and pollinator functional groups as the main differentiated guilds in life form and behaviour. Then, we explored the main motifs of these networks and we found [...]

##METHODS

**Plant-pollinator studies**

We have compiled 60 plant-pollinator networks from 18 different studies (Table S1). All studies sampled plant-pollinator interactions in natural systems and were selected based on wide geographical coverage and the presence of interaction frequency as a measure of interaction strength. In total, there were 503 plant species, 1111 pollinator species and 6248 of pairwise interactions registered. For ease of data manipulation plant and pollinator species names were standardize with the help of the package taxize version 0.9.99 [@chamberlain2020].

**Plant and pollinator functional groups**

First, plant species were grouped into the optimal number of functional groups that summarized the main plant reproductive strategies. This was done with the help of hierarchical cluster analysis by using the trait dataset compiled in Lanuza et al., (unpublished). This dataset consisted on x floral, x reproductive and x vegetative traits (Table S2). For this, we calculated the distance of the different functional traits with the function gowdis from the package FD version 1.0-12 (Laliberté et al., 2014) with the method ward.D2 used for non-squared distances (Murtagh & Legendre, 2014). All the numerical traits were previously scaled. Finally, we applied a hierarchical cluster analysis with the function hclust from the R stats package version 4.0.5 and calculated the optimal number of clusters with the function kgs from the package maptree version 1.4-7 (White & Gramacy, 2009).

Second, pollinators were grouped into functional groups based on taxonomic rank. We opted to divide pollinators on the taxonomic rank level and not with functional traits because (i) they main taxonomic orders differ in form and behaviour and (ii) the lower complexity of higher taxonomic ranks (i.e., pollinators had 6 orders versus plants that had 38). Hence, we grouped pollinators into 6 functional groups: (i) Hymenoptera-Anthophila (bees), (ii) Hymenoptera-non-Anthophila (other non-bee Hymenoptera), (iii) Syrphidae-Diptera, (iv) non-Syrphidae-Diptera, (v) Lepidoptera and (vi) Coleoptera. 


**Meso-scale analysis**

Following Simmons et al. [@simmons2019,@simmons2020], we broke down the plant-pollinator networks into their constituent motifs. Prior to analyses, we selected only robust links, that is, interactions whose frequency was greater than one (64.94 % interactions); and, then, we turned the quantitative networks into qualitative (or binary) ones, where interactions are present or absent. 

We calculated the frequency of all motifs up to five nodes (see motif topologies in Figure 3 in [@simmons2019]) for each empirical and simulated network, by using the ‘bmotif’ package [@bmotifsimmons2019]. To control for variation in network size and for the fact that smaller motifs can be nested within larger motifs, motif frequencies were normalised as a proportion of the total number of motifs within each motif class (i.e., the number of nodes a motif contains). Like [@simmons2020], we just used five-node motifs in our analyses for visualisation, interpretation and computational reasons. In addition, we excluded from our analyses two-node motifs (or links) because their normalised frequency would always equal one.

To assess the significance of the observed frequencies, we created 1,000 simulated networks for each binary network using the ‘nullmodel’ function and the ‘vaznull’ model in the bipartite package [@dormann2009]. Generated networks had the same number of plants and pollinators, and the same connectance of their corresponding empirical networks. After extracting the motif frequencies from the simulated networks, we calculated the percentage of simulated networks whose motif frequencies were smaller than the observed frequency for each motif type and empirical network, that is, we estimated the percentile of the observed motif frequencies. Motifs whose percentile is close to zero or 100 are under- or over-represented in the empirical networks, respectively, and, thus, they cannot be predicted by connectance and the number of species alone. To summarize general patterns across networks, we used an intercept-only linear mixed model (LMM) per motif, where the response variable was the observed motif percentile per network. In these models, we used the study identifiers in Table S1 as a random intercept. By doing so, we obtained estimates of the average motif frequency, in which we controlled the variation at the study level. 

Next, we calculated which functional groups were over or under-represented in different motif positions by comparing position frequencies of empirical networks with those of their corresponding simulated networks. For each network, we extracted the position frequencies of all motifs from three to five nodes for each species by using the ‘bmotif’ package [@bmotifsimmons2019]. To estimate the position frequencies of each functional in a given network, we added the frequencies of those species that belong to the same group and we normalised the resulting frequencies by dividing the position measure for each group by the total number of times that a group appears in any position within the same motif size class. Then, we calculated the percentile of the observed position frequencies for each group and network, just like we did motif frequencies. To  outline the general patterns of position frequencies across networks and functional groups, we fit a LMM per motif position, where the response variable was the observed position percentile per network. We used the functional group identifier as an explanatory variable and the study identifiers as a random intercept. By adding the functional group estimates to the model intercept, we assessed the average motif frequency, after controlling the variation at the study level. To fit the LMMs models in our analyses, we used the ‘lmer’ package [@bates2015].

[potential additions: 
Finally,for each motif, we recover the number of times a given combination of functional groups emerges ...
Finally, we draw a network collapsing nodes per FG...]

##RESULTS

0) Description of guilds and FG. 

1) over and under represented motifs
```{r, echo=FALSE, message=FALSE, cache=FALSE,  warning=FALSE, fig.cap="Figure 1."}
library(lme4)
library(nlme)
library(tidyverse)
source("../Scripts/Scripts_Alfonso/add_study_id.R")
d <- read_csv("../Data/Csv/Motifs_frequencies_and_null_models/Motifs_frequency_percentile.csv")
d <- add_study_id(d)
#str(d)
#head(d)

#ggplot(d %>% filter(motif != 1), aes(percentil_sizeclass))+
#  geom_histogram(color="black", fill="white")+
#  facet_wrap(~motif)+
#  theme_bw()+
#  labs(x="Sizeclass percentile")
#
# Motifs tend to be over- and under-represensented in real networks

# Mean percentile and SE taking into account the study system
motif_codes <- d %>% filter(motif != 1) %>% # We remove links (motif code: 1)
  select(motif) %>% unique() %>% pull()
motif_means <- tibble(motif = motif_codes)
motif_means$mean <- NA
motif_means$SE <- NA

for(i.motif in 1:length(motif_codes)){
  
  m <- lmer(percentil_sizeclass ~ 1+(1|study_id), #HERE WE NEED STUDY SYSTEM ONLY!! 
            data = subset(d, motif == motif_codes[i.motif]))  
  
  motif_means$mean[i.motif] <- fixed.effects(m) %>% unname()
  motif_means$SE[i.motif] <- sqrt(diag(vcov(m)))
  
}


ggplot(NULL) + 
  geom_point(data = d %>% filter(motif != 1),
             aes(y=as.factor(motif), x=percentil_sizeclass, 
                 color = as.factor(motif)),
             position = "jitter",alpha=0.5)+
  geom_errorbar(data = motif_means,aes(y = as.factor(motif), xmin=mean-SE, xmax=mean+SE), 
                width=1.0,size=1)+
  geom_point(data = motif_means,aes(y = as.factor(motif), x=mean), 
                size=2)+
  labs(y="Motif", x = "Percentile")+
  theme_bw()+
  theme(legend.position = "none")

#Fig 1 Should be a dot plot (or forest plot) of the mean +- SE of the 15 motifs.
#NICE! Can we put motifs in Y axes, and % in X?
```
2) FG-position associations.
```{r, echo=FALSE, message=FALSE, cache=FALSE,  warning=FALSE}
library(lme4)
library(nlme)
library(tidyverse)
library(stringi)
library(ggpubr)
source("../Scripts/Scripts_Alfonso/add_study_id.R")

all_position_percentiles <- read_csv("../Data/Csv/Motifs_positions_and_null_models/GF_positions_frequency_percentile.csv")

all_position_percentiles$position <- stri_extract_first_regex(all_position_percentiles$position,
                                                              "[0-9]+") %>% as.numeric()

all_position_percentiles <- add_study_id(all_position_percentiles)
str(all_position_percentiles)
head(all_position_percentiles)

list_plants_FG <- as.character(1:10)

plant_position_percentiles_filtered <- all_position_percentiles %>% 
  filter(Node_FG %in% list_plants_FG, !position %in% c(1,2),
         !is.na(expected_freq_its_GF)) #ME DA ERROR
pollinator_position_percentiles_filtered <- all_position_percentiles %>% 
  filter(!Node_FG %in% list_plants_FG, !position %in% c(1,2),
         !is.na(expected_freq_its_GF))

ggplot(plant_position_percentiles_filtered, aes(percentil_its_GF))+
  geom_histogram(color="black", fill="white")+
  facet_wrap(~position)+
  theme_bw()+
  labs(x="Sizeclass percentile", title = "Histograms: Percentiles for plant positions")

ggplot(pollinator_position_percentiles_filtered, aes(percentil_its_GF))+
  geom_histogram(color="black", fill="white")+
  facet_wrap(~position)+
  theme_bw()+
  labs(x="Sizeclass percentile",title = "Histograms: Percentiles for pollinator positions")



# estimated mean taking into account the random str is 0.XX +- 0.XX (look at the (Intercept) estimate)


# Plants-------------

# Mean percentile and SE taking into account the study system
plant_codes <- plant_position_percentiles_filtered$position %>% unique()
plant_means <- plant_position_percentiles_filtered %>% select(position,Node_FG) %>% unique()
plant_means$mean <- NA
plant_means$SE <- NA


for(i.pos in 1:length(plant_codes)){
  
  m <- lmer(percentil_its_GF ~ Node_FG + (1|study_id),
            data = plant_position_percentiles_filtered %>%
                          filter(position == plant_codes[i.pos]))  
  
  temp <- fixed.effects(m) %>% unname()
  plant_means$mean[plant_means$position == plant_codes[i.pos]] <- c(temp[1],
                                                                     temp[1]+temp[2],
                                                                     temp[1]+temp[3],
                                                                     temp[1]+temp[4],
                                                                     temp[1]+temp[5]) ## to get real means per FG
  temp <- sqrt(diag(vcov(m)))
  plant_means$SE[plant_means$position == plant_codes[i.pos]] <- c(temp[1], 
                                                                  temp[1]+temp[2],
                                                                  temp[1]+temp[3],
                                                                  temp[1]+temp[4],
                                                                  temp[1]+temp[5])
  
}

GF_plant_pos <- ggplot(NULL) + 
  geom_point(data = plant_position_percentiles_filtered,
             aes(x=as.factor(position), y=percentil_its_GF, 
                 color = as.factor(position)),
             position = "jitter",alpha=0.5)+
  geom_errorbar(data = plant_means,aes(x = as.factor(position), ymin=mean-SE, ymax=mean+SE), 
                width=1.0,size=1)+
  facet_wrap(~Node_FG,ncol = 5)+
  geom_point(data = plant_means,aes(x = as.factor(position), y=mean), 
             size=2)+
  labs(x="Position", y = "Percentile",title = "Plants")+
  theme_bw()+
  theme(legend.position = "none")+#,axis.text.x=element_text(angle=90,vjust=0.5, hjust=1))+
  coord_flip()


# Pollinators--------

# Mean percentile and SE taking into account the study system
pollinator_codes <- pollinator_position_percentiles_filtered$position %>% unique()
pollinator_means <- pollinator_position_percentiles_filtered %>% select(position,Node_FG) %>% unique()
pollinator_means$mean <- NA
pollinator_means$SE <- NA
pollinator_means_reordered <- NULL

for(i.pos in 1:length(pollinator_codes)){
  
  m <- lmer(percentil_its_GF ~ Node_FG + (1|study_id), #HERE WE NEED STUDY SYSTEM ONLY!! 
            data = pollinator_position_percentiles_filtered %>%
                          filter(position == pollinator_codes[i.pos]),
            control = lmerControl(optimizer ="Nelder_Mead")) # I changed the optimizer because motif 8 (i.pos = 3) caused convergence problems, max gradient = 0.0022 > 0.002.
  
  temp <- fixed.effects(m) %>% unname()
  pollinator_means_aux <- pollinator_means[pollinator_means$position == pollinator_codes[i.pos],] %>% arrange(Node_FG)
  
  pollinator_means_aux$mean <- c(temp[1],
                                 temp[1]+temp[2],
                                 temp[1]+temp[3],
                                 temp[1]+temp[4],
                                 temp[1]+temp[5],
                                 temp[1]+temp[6],
                                 temp[1]+temp[7],
                                 temp[1]+temp[8],
                                 temp[1]+temp[9]) ## to get real means per FG
    
                                                                    
  temp <- sqrt(diag(vcov(m)))
  pollinator_means_aux$SE <- c(temp[1],
                               temp[1]+temp[2],
                               temp[1]+temp[3],
                               temp[1]+temp[4],
                               temp[1]+temp[5],
                               temp[1]+temp[6],
                               temp[1]+temp[7],
                               temp[1]+temp[8],
                               temp[1]+temp[9])
  
  pollinator_means_reordered <- bind_rows(pollinator_means_reordered,pollinator_means_aux)
    
}

# There are lower limits (mean - SE) smaller than 0 (see Other insects)
# We set the lower limit of those error bars to zero

pollinator_means_reordered <- pollinator_means_reordered %>% mutate(lower = mean-SE)
pollinator_means_reordered$lower[pollinator_means_reordered$lower < 0] <- 0

GF_poll_pos <- ggplot(NULL) + 
  geom_point(data = pollinator_position_percentiles_filtered,
             aes(x=as.factor(position), y=percentil_its_GF, 
                 color = as.factor(position)),
             position = "jitter",alpha=0.5)+
  geom_errorbar(data = pollinator_means_reordered, aes(x = as.factor(position), ymin=lower,
                                                       ymax=mean+SE), 
                width=1.0,size=1)+
  facet_wrap(~Node_FG,ncol = 5)+
  geom_point(data = pollinator_means_reordered,aes(x = as.factor(position), y=mean), 
             size=2)+
  labs(x="Position", y = "Percentile", title = "Pollinators")+
  theme_bw()+
  theme(legend.position = "none")+#,axis.text.x=element_text(angle=90,vjust=0.5, hjust=1))+
  coord_flip()


# Plant and Pollinators--------

ggarrange(GF_plant_pos,GF_poll_pos,
          ncol = 1, nrow = 2,heights = c(.90, 1.4))

#Fig 2 may be the same, but for the each positions-FG combination? Maybe heatmap (but we lose the SE's)

```

##REFERENCES

<div id ="refs"></div>


##SUPPLEMENTARY MATERIAL


```{r, echo=FALSE, message=FALSE, cache=FALSE,  warning=FALSE,fig.align = "left"}
##############################
#TABLE S1. List of studies
##############################

#Load libraries
library(kableExtra)
library(dplyr)

#Create data.frame with references

#vector with number of netw per study
`Number of networks` <- c("6", "2", "3", "1", "1", "1", "1", "2", "1", "1", "8", "16", "6", "2", "4", "1", "3", "1")

#`Network structure` <- c(rep("Web", 22), rep("Metaweb",6))

`First author` <- c("Bartomeus", "Dicks", "Dupont", "Elberling", "Fang", "Inouye", "Lundgren", "Olesen", "Small", "Souza", "Kaiser-Bunbury", "Bartomeus", 
                    "Kaiser-Bunbury", "Kaiser-Bunbury", "Peralta", "Burkle", "Arroyo-Correa", "Bundgaard")

Year <- c(2008,2002,2003,1999,2008,1988, 2005,2002,1976,2017,2017,2008,2011,2010,2006,2013,2019,2003)

#Country <- c("Spain", "England", "Denmark", "Sweden", "China", "Australia", "Greenland", "Mauritius and Azores", #"Canada", "Brasil", "Seychelles", "Spain", "Seychelles",
#"Mauritius", "Argentina", "USA", "New Zealand", "Denmark",  "Denmark", "Japan", "Canada", "Venezuela", "Japan", #"Ecuador", "New Zealand", "Venezuela",
#"USA", "Ecuador")

DOI <- c("https://doi.org/10.1007/s00442-007-0946-1", "https://doi.org/10.1046/j.0021-8790.2001.00572.x", "https://doi.org/10.1111/j.1365-2656.2008.01501.x",
         "https://doi.org/10.1111/j.1600-0587.1999.tb00507.x", "https://doi.org/10.1111/1749-4877.12190", "https://doi.org/10.1111/j.1442-9993.1988.tb00968.x",
         "https://doi.org/10.1657/1523-0430(2005)037[0514:TDAHCW]2.0.CO;2", "https://doi.org/10.1046/j.1472-4642.2002.00148.x",
         "/13960/t4km08d21", "https://doi.org/10.1111/1365-2745.12978", "https://doi.org/10.1038/nature21071", "https://github.com/ibartomeus/BeeFunData",
         "https://doi.org/10.1111/j.1365-2745.2010.01732.x", "https://doi.org/10.1016/j.ppees.2009.04.001", "https://doi.org/10.1111/ele.13510",
         "https://doi.org/10.1126/science.1232728", "https://doi.org/10.1111/1365-2745.13332", "Unpublished, Master thesis")


references <- data.frame(`First author`, Year, `Number of networks`,   DOI)

colnames(references) <- c("First author", "Year", "Number of networks",  "DOI")

#Check number of studies
#nrow(references) # 18 studies
#check number of networks
#sum(as.numeric(references$`Number of networks`)) #60

references %>%
  arrange(`First author`)%>%
  kable( longtable = T, booktabs = T,linesep = "\\addlinespace",align = c("cccc"),caption = "Table S1. List of studies ordered by author with the year of publication, number of contributed networks and digital object identifier") %>%
  kable_styling(latex_options = c("repeat_header","striped"), font_size = 12, full_width=F,position = c("left"))

```


```{r, echo=FALSE, message=FALSE, cache=FALSE, results='hide', warning=FALSE, fig.height=7, fig.width=13, fig.cap="Figure S1. Plant functional groups composition separated in qualitative and quantitative variables. Panel A) shows the percentage of the different categories within trait represented with different colours for each functional group. Plot B) shows the radar plot of the different quantitative variables standardize on the same scale also coloured with the same patterns of colours as qualitative variables per cluster."}


#CODE TO PLOT FUNCTIONAL GROUPS
#IT CAN BE PLOT WITH MUCH LESS CODE BUT NO TIME FOR CLEANING IT


##########################################
#Visualization of plant functional groups#
##########################################

library(cowplot)
library(ggplot2)
library(tidyr)
library(dplyr)
library(reshape2)
library(data.table)
library(patchwork)

#LOAD DATA
#read unscaled trait data in order to visualize better the clusters
d <- read.csv("../Data/Csv/all_species_imputed_trait_data_forest_data.csv")

dat_1 <- read.csv("../Data/Csv/imputed_trait_data_hclust_5_clusters_forest_data.csv", row.names = "X") 

d$Clusters <- dat_1$Clusters

#select columns of interest
t <- d[c("Breeding_system","IMPUTED_Compatibility","Autonomous_selfing_level",
         "Autonomous_selfing_level_fruit_set", "Flower_morphology", "Flower_symmetry", "Flowers_per_plant", "Flowers_per_inflorescence",
         "Floral_unit_width", "Corolla_diameter_mean", "Corolla_length_mean", "STYLE_IMPUTED", "OVULES_IMPUTED", "life_form", "lifespan",
         "IMPUTED_plant_height_mean_m", "Nectar_presence_absence", "Clusters")]



##############################################################################################################################
#Prepare table qualitative variables
##############################################################################################################################

##############################################################################################################################
#Breeding system
t$Breeding_system <- factor(t$Breeding_system, levels=c("Dioecious", "Monoecious", "Hermaphrodite"))

#Summary to create table
breeding <- t %>%
  group_by(Clusters,Breeding_system) %>%
  summarise (n = n()) %>%
  mutate(Percentage = n / sum(n)*100)

breeding <- breeding[,-3]

breeding <- spread(breeding, Clusters, Percentage)

colnames(breeding)[1] <- "Category"

Trait <- data.frame(Trait= c(rep("Breeding system", 3)))

Breeding_system <- cbind(Trait, breeding)

##############################################################################################################################
#Compatibility
str(t)
t$IMPUTED_Compatibility <- as.character(t$IMPUTED_Compatibility)
t$IMPUTED_Compatibility[t$IMPUTED_Compatibility=="dioecious"] <- "Unisexual flower"
t$IMPUTED_Compatibility[t$IMPUTED_Compatibility=="monoecious"] <- "Unisexual flower"
t$IMPUTED_Compatibility[t$IMPUTED_Compatibility=="self_incompatible"] <- "Self incompatible"
t$IMPUTED_Compatibility[t$IMPUTED_Compatibility=="partially_self_compatible"] <- "Partially self compatible"
t$IMPUTED_Compatibility[t$IMPUTED_Compatibility=="self_compatible"] <- "Self compatible"

t$IMPUTED_Compatibility <- factor(t$IMPUTED_Compatibility, levels=c("Unisexual flower", "Self incompatible", "Partially self compatible", "Self compatible"))
#Summary to create table
comp <- t %>%
  group_by(Clusters,IMPUTED_Compatibility) %>%
  summarise (n = n()) %>%
  mutate(Percentage = n / sum(n)*100)

comp <- comp[,-3]

comp <- spread(comp, Clusters, Percentage)
#Replace Na's with zeros
comp[is.na(comp)] <- 0
#Set call name os categories per trait
colnames(comp)[1] <- "Category"
#Create new column
Trait <- data.frame(Trait= c(rep("Compatibility system", 4)))
#Add column
Compatibility_system <- cbind(Trait, comp)
#Bind rows
bind_rows(Breeding_system, Compatibility_system)


############################################################################################################################################
#Life form
t$life_form <- as.character(t$life_form)
t$life_form[t$life_form =="vine"] <- "Shrub"
t$life_form[t$life_form =="tree"] <- "Tree"
t$life_form[t$life_form =="herb"] <- "Herb"
t$life_form[t$life_form =="shrub"] <- "Shrub"
#Order levels
t$life_form <- factor(t$life_form, levels=c("Tree", "Shrub", "Herb"))
#Summary to create table
life_form <- t %>%
  group_by(Clusters,life_form) %>%
  summarise (n = n()) %>%
  mutate(Percentage = n / sum(n)*100)
#delete column to convert to wide
life_form <- life_form[,-3]
#convert to wide
life_form <- spread(life_form, Clusters, Percentage)
#Set call name os categories per trait
colnames(life_form)[1] <- "Category"
#Create new column
Trait <- data.frame(Trait= c(rep("Life form", 3)))
#Add column
Life_form<- cbind(Trait, life_form)
#Bind rows
bind_rows(Breeding_system, Compatibility_system, Life_form)

############################################################################################################################################
t$lifespan <- factor(t$lifespan, levels=c("Perennial","Short lived"))
#Summary to create table
life_span <- t %>%
  group_by(Clusters,lifespan) %>%
  summarise (n = n()) %>%
  mutate(Percentage = n / sum(n)*100)
#delete column to convert to wide
life_span <- life_span[,-3]
#convert to wide
life_span <- spread(life_span, Clusters, Percentage)
#Set call name os categories per trait
colnames(life_span)[1] <- "Category"
#Create new column
Trait <- data.frame(Trait= c(rep("Life span", 2)))
#Add column
Life_span<- cbind(Trait, life_span)
#Bind rows
bind_rows(Breeding_system, Compatibility_system, Life_form, Life_span)

############################################################################################################################################
t$Flower_morphology <- as.character(t$Flower_morphology)
t$Flower_morphology[t$Flower_morphology=="Funnelform"] <- "Campanulate"
t$Flower_morphology[t$Flower_morphology=="Spike"] <- "Brush"

Flower_morphology <- t %>%
  group_by(Clusters,Flower_morphology) %>%
  summarise (n = n()) %>%
  mutate(Percentage = n / sum(n)*100)
#delete column to convert to wide
Flower_morphology <- Flower_morphology[,-3]
#convert to wide
Flower_morphology <- spread(Flower_morphology, Clusters, Percentage)
#Set call name os categories per trait
colnames(Flower_morphology)[1] <- "Category"
#Create new column
Trait <- data.frame(Trait= c(rep("Flower shape", 6)))
#Add column
Flower_morphology<- cbind(Trait, Flower_morphology)
#Replace Na's with zeros
Flower_morphology[is.na(Flower_morphology)] <- 0
#Bind rows
bind_rows(Breeding_system, Compatibility_system, Life_form, Life_span,Flower_morphology)

############################################################################################################################################
t$Flower_symmetry <- as.character(t$Flower_symmetry)
t$Flower_symmetry[t$Flower_symmetry =="actinomorphic"] <- "Actinomorphic"
t$Flower_symmetry[t$Flower_symmetry =="zygomorphic"] <- "Zygomorphic"

Flower_symmetry <- t %>%
  group_by(Clusters,Flower_symmetry) %>%
  summarise (n = n()) %>%
  mutate(Percentage = n / sum(n)*100)
#delete column to convert to wide
Flower_symmetry <- Flower_symmetry[,-3]
#convert to wide
Flower_symmetry <- spread(Flower_symmetry, Clusters, Percentage)
#Set call name os categories per trait
colnames(Flower_symmetry)[1] <- "Category"
#Create new column
Trait <- data.frame(Trait= c(rep("Flower symmetry", 2)))
#Add column
Flower_symmetry<- cbind(Trait, Flower_symmetry)
#Bind rows
bind_rows(Breeding_system, Compatibility_system, Life_form, Life_span,Flower_morphology,Flower_symmetry)
############################################################################################################################################
t$Autonomous_selfing_level <- as.character(t$Autonomous_selfing_level)
t$Autonomous_selfing_level[t$Autonomous_selfing_level =="none"] <- "None"
t$Autonomous_selfing_level[t$Autonomous_selfing_level =="low"] <- "Low"
t$Autonomous_selfing_level[t$Autonomous_selfing_level =="medium"] <- "Medium"
t$Autonomous_selfing_level[t$Autonomous_selfing_level =="high"] <- "High"

#Order levels
t$Autonomous_selfing_level <- factor(t$Autonomous_selfing_level, levels=c("High", "Medium", "Low", "None"))

Selfing <- t %>%
  group_by(Clusters,Autonomous_selfing_level) %>%
  summarise (n = n()) %>%
  mutate(Percentage = n / sum(n)*100)

#delete column to convert to wide
Selfing <- Selfing[,-3]
#convert to wide
Selfing <- spread(Selfing, Clusters, Percentage)
#Set call name os categories per trait
colnames(Selfing)[1] <- "Category"
#Create new column
Trait <- data.frame(Trait= c(rep("Selfing level", 2)))
#Replace Na's with zeros
Selfing[is.na(Selfing)] <- 0
#Add column
Selfing_1 <- cbind(Trait, Selfing)
#Bind rows
bind_rows(Breeding_system, Compatibility_system, Life_form, Life_span,Flower_morphology, Selfing_1)

############################################################################################################################################
t$Nectar_presence_absence <- as.character(t$Nectar_presence_absence)
t$Nectar_presence_absence[t$Nectar_presence_absence =="yes"] <- "Yes"
t$Nectar_presence_absence[t$Nectar_presence_absence =="no"] <- "No"

Nectar <- t %>%
  group_by(Clusters,Nectar_presence_absence) %>%
  summarise (n = n()) %>%
  mutate(Percentage = n / sum(n)*100)

#delete column to convert to wide
Nectar <- Nectar[,-3]
#convert to wide
Nectar <- spread(Nectar, Clusters, Percentage)
#Set call name os categories per trait
colnames(Nectar)[1] <- "Category"
#Create new column
Trait <- data.frame(Trait= c(rep("Nectar", 2)))
#Replace Na's with zeros
Nectar[is.na(Nectar)] <- 0
#Add column
Nectar <- cbind(Trait, Nectar)
#Bind rows
bind_rows(Breeding_system, Compatibility_system, Life_form, Life_span,Flower_morphology, Flower_symmetry,Selfing_1, Nectar)


##############################################################################################################################
#Prepare table quantitative variables
##############################################################################################################################

Selfing <-  t %>% group_by(Clusters)%>% 
  select(Autonomous_selfing_level_fruit_set) %>% # select variables to summarise
  summarise_each(funs(min = min,
                     # q25 = quantile(., 0.25), 
                      median = median, 
                      #q75 = quantile(., 0.75), 
                      max = max,
                      mean = mean, 
                    sd = sd))
  

s1 <- as.data.frame(t(Selfing))
#set colnames
colnames(s1) <- c("1","2","3","4","5")
#remove the cluster row
s1 <- s1[-1,]
#convert rownames to 1st columns
s1 <- setDT(s1, keep.rownames = "TRUE")[]
colnames(s1)[1] <- "Category"
#Create data frame to add grouping variable
Trait <- data.frame(Trait= c(rep("Autonomous selfing", 5)))
#Add column
Selfing <- cbind(Trait, s1)

##############################################################################################################################
flower_number <-  t %>% group_by(Clusters)%>% 
  select(Flowers_per_plant) %>% # select variables to summarise
  summarise_each(funs(min = min,
                      # q25 = quantile(., 0.25), 
                      median = median, 
                      #q75 = quantile(., 0.75), 
                      max = max,
                      mean = mean, 
                      sd = sd))


f1 <- as.data.frame(t(flower_number))
#set colnames
colnames(f1) <- c("1","2","3","4","5")
#remove the cluster row
f1 <- f1[-1,]
#convert rownames to 1st columns
f1 <- setDT(f1, keep.rownames = "TRUE")[]
colnames(f1)[1] <- "Category"
#Create data frame to add grouping variable
Trait <- data.frame(Trait= c(rep("Flower number", 5)))
#Add column
Flower_number <- cbind(Trait, f1)


##############################################################################################################################
Flowers_per_inflorescence <-  t %>% group_by(Clusters)%>% 
  select(Flowers_per_inflorescence) %>% # select variables to summarise
  summarise_each(funs(min = min,
                      # q25 = quantile(., 0.25), 
                      median = median, 
                      #q75 = quantile(., 0.75), 
                      max = max,
                      mean = mean, 
                      sd = sd))


f_i_1 <- as.data.frame(t(Flowers_per_inflorescence))
#set colnames
colnames(f_i_1) <- c("1","2","3","4","5")
#remove the cluster row
f_i_1 <- f_i_1[-1,]
#convert rownames to 1st columns
f_i_1 <- setDT(f_i_1, keep.rownames = "TRUE")[]
colnames(f_i_1)[1] <- "Category"
#Create data frame to add grouping variable
Trait <- data.frame(Trait= c(rep("Flowers per inflorescence", 5)))
#Add column
Flower_per_inflo <- cbind(Trait, f_i_1)

bind_rows(Selfing, Flower_number, Flower_per_inflo)

##############################################################################################################################
Floral_unit_width <-  t %>% group_by(Clusters)%>% 
  select(Floral_unit_width) %>% # select variables to summarise
  summarise_each(funs(min = min,
                      # q25 = quantile(., 0.25), 
                      median = median, 
                      #q75 = quantile(., 0.75), 
                      max = max,
                      mean = mean, 
                      sd = sd))


f_u_w_1 <- as.data.frame(t(Floral_unit_width))
#set colnames
colnames(f_u_w_1) <- c("1","2","3","4","5")
#remove the cluster row
f_u_w_1 <- f_u_w_1[-1,]
#convert rownames to 1st columns
f_u_w_1 <- setDT(f_u_w_1, keep.rownames = "TRUE")[]
colnames(f_u_w_1)[1] <- "Category"
#Create data frame to add grouping variable
Trait <- data.frame(Trait= c(rep("Inflorescence width", 5)))
#Add column
Inflo_width <- cbind(Trait, f_u_w_1)

bind_rows(Selfing, Flower_number, Flower_per_inflo, Inflo_width)

##############################################################################################################################
Corolla_diameter_mean <-  t %>% group_by(Clusters)%>% 
  select(Corolla_diameter_mean) %>% # select variables to summarise
  summarise_each(funs(min = min,
                      # q25 = quantile(., 0.25), 
                      median = median, 
                      #q75 = quantile(., 0.75), 
                      max = max,
                      mean = mean, 
                      sd = sd))


c_w_1 <- as.data.frame(t(Corolla_diameter_mean))
#set colnames
colnames(c_w_1) <- c("1","2","3","4","5")
#remove the cluster row
c_w_1 <- c_w_1[-1,]
#convert rownames to 1st columns
c_w_1 <- setDT(c_w_1, keep.rownames = "TRUE")[]
colnames(c_w_1)[1] <- "Category"
#Create data frame to add grouping variable
Trait <- data.frame(Trait= c(rep("Flower width", 5)))
#Add column
Flower_width <- cbind(Trait, c_w_1)

bind_rows(Selfing, Flower_number, Flower_per_inflo, Inflo_width, Flower_width)


##############################################################################################################################
Corolla_length_mean <-  t %>% group_by(Clusters)%>% 
  select(Corolla_length_mean) %>% # select variables to summarise
  summarise_each(funs(min = min,
                      # q25 = quantile(., 0.25), 
                      median = median, 
                      #q75 = quantile(., 0.75), 
                      max = max,
                      mean = mean, 
                      sd = sd))


c_l_1 <- as.data.frame(t(Corolla_length_mean))
#set colnames
colnames(c_l_1) <- c("1","2","3","4","5")
#remove the cluster row
c_l_1 <- c_l_1[-1,]
#convert rownames to 1st columns
c_l_1 <- setDT(c_l_1, keep.rownames = "TRUE")[]
colnames(c_l_1)[1] <- "Category"
#Create data frame to add grouping variable
Trait <- data.frame(Trait= c(rep("Flower length", 5)))
#Add column
Flower_length<- cbind(Trait, c_l_1)

bind_rows(Selfing, Flower_number, Flower_per_inflo, Inflo_width, Flower_width, Flower_length)

##############################################################################################################################
STYLE_IMPUTED <-  t %>% group_by(Clusters)%>% 
  select(STYLE_IMPUTED) %>% # select variables to summarise
  summarise_each(funs(min = min,
                      # q25 = quantile(., 0.25), 
                      median = median, 
                      #q75 = quantile(., 0.75), 
                      max = max,
                      mean = mean, 
                      sd = sd))


s_l_1 <- as.data.frame(t(STYLE_IMPUTED))
#set colnames
colnames(s_l_1) <- c("1","2","3","4","5")
#remove the cluster row
s_l_1 <- s_l_1[-1,]
#convert rownames to 1st columns
s_l_1 <- setDT(s_l_1, keep.rownames = "TRUE")[]
colnames(s_l_1)[1] <- "Category"
#Create data frame to add grouping variable
Trait <- data.frame(Trait= c(rep("Style length", 5)))
#Add column
Style_length<- cbind(Trait, s_l_1)

bind_rows(Selfing, Flower_number, Flower_per_inflo, Inflo_width, Flower_width, Flower_length, Style_length)

##############################################################################################################################

OVULES_IMPUTED <-  t %>% group_by(Clusters)%>% 
  select(OVULES_IMPUTED) %>% # select variables to summarise
  summarise_each(funs(min = min,
                      # q25 = quantile(., 0.25), 
                      median = median, 
                      #q75 = quantile(., 0.75), 
                      max = max,
                      mean = mean, 
                      sd = sd))


o_n_1 <- as.data.frame(t(OVULES_IMPUTED))
#set colnames
colnames(o_n_1) <- c("1","2","3","4","5")
#remove the cluster row
o_n_1 <- o_n_1[-1,]
#convert rownames to 1st columns
o_n_1 <- setDT(o_n_1, keep.rownames = "TRUE")[]
colnames(o_n_1)[1] <- "Category"
#Create data frame to add grouping variable
Trait <- data.frame(Trait= c(rep("Ovule number", 5)))
#Add column
Ovule_number <- cbind(Trait, o_n_1)

bind_rows(Selfing, Flower_number, Flower_per_inflo, Inflo_width, Flower_width, Flower_length, Ovule_number)


##############################################################################################################################

IMPUTED_plant_height_mean_m <-  t %>% group_by(Clusters)%>% 
  select(IMPUTED_plant_height_mean_m) %>% # select variables to summarise
  summarise_each(funs(min = min,
                      # q25 = quantile(., 0.25), 
                      median = median, 
                      #q75 = quantile(., 0.75), 
                      max = max,
                      mean = mean, 
                      sd = sd))


p_h_1 <- as.data.frame(t(IMPUTED_plant_height_mean_m))
#set colnames
colnames(p_h_1) <- c("1","2","3","4","5")
#remove the cluster row
p_h_1 <- p_h_1[-1,]
#convert rownames to 1st columns
p_h_1 <- setDT(p_h_1, keep.rownames = "TRUE")[]
colnames(p_h_1)[1] <- "Category"
#Create data frame to add grouping variable
Trait <- data.frame(Trait= c(rep("Plant height", 5)))
#Add column
Plant_height <- cbind(Trait, p_h_1)


#Bind quantitative and qualitative variables
Table_all_traits <- bind_rows(Breeding_system, Compatibility_system, Life_form, Life_span,Flower_morphology, Flower_symmetry,Selfing_1, Nectar,
          Selfing, Flower_number, Flower_per_inflo, Inflo_width, Flower_width, Flower_length, Style_length, Ovule_number, Plant_height)

#Select just two decimals
is.num <- sapply(Table_all_traits, is.numeric)
Table_all_traits[is.num] <- lapply(Table_all_traits[is.num], round, 2)

colnames(Table_all_traits) <- c("Trait", "Category", "Cluster 1", "Cluster 2", "Cluster 3", "Cluster 4", "Cluster 5") 




#LOAD LIBRARIES
#devtools::install_github("ricardo-bion/ggradar", dependencies=TRUE)
suppressPackageStartupMessages(library(dplyr))
library(scales)
library(tibble)
library(ggradar)
library(janitor)
library(grid)
library(dplyr)
library(lubridate)
#QUANTITATIVVE VARIABLES

#generate subset of quantitative variables for plotting
quant_median <- subset(Table_all_traits, Category=="median")

#delete col number 2
quant_median <- quant_median[,-2]

#transpose dataframe
final_df <- as.data.frame(t(quant_median))

#rownames to colnames (1st one)
final_df_1 <- final_df %>% row_to_names(row_number = 1)

#Convert all variables to numeric
final_df_2 <- sapply(final_df_1, function(x) as.numeric(as.character(x)))

#set back the missed rownames in the processing
rownames(final_df_2) <- rownames(final_df_1)

# Convert to dataframe
final_df_2 <- as.data.frame(final_df_2)

# Scale values and set rowname as column
final_df_3 <-final_df_2 %>% rownames_to_column( var = "group" ) %>%   mutate_at(vars(-group),funs(rescale)) 

#Plot Radar
#ggradar(final_df_3) 


#QUALITATIVE VARIABLES

#LOAD DATA
#read unscaled trait data in order to visualize better the clusters
d <- read.csv("../Data/Csv/all_species_imputed_trait_data_forest_data.csv")

dat_1 <- read.csv("../Data/Csv/imputed_trait_data_hclust_5_clusters_forest_data.csv", row.names = "X") 

d$Clusters <- dat_1$Clusters

#select columns of interest
t <- d[c("Breeding_system","IMPUTED_Compatibility","Autonomous_selfing_level",
         "Autonomous_selfing_level_fruit_set", "Flower_morphology", "Flower_symmetry", "Flowers_per_plant", "Flowers_per_inflorescence",
         "Floral_unit_width", "Corolla_diameter_mean", "Corolla_length_mean", "STYLE_IMPUTED", "OVULES_IMPUTED", "life_form", "lifespan",
         "IMPUTED_plant_height_mean_m", "Nectar_presence_absence", "Clusters")]



##############################################################################################################################
#Prepare table qualitative variables
##############################################################################################################################

##############################################################################################################################
#Breeding system
t$Breeding_system <- factor(t$Breeding_system, levels=c("Dioecious", "Monoecious", "Hermaphrodite"))

#Summary to create table
breeding <- t %>%
  group_by(Clusters,Breeding_system) %>%
  summarise (n = n()) %>%
  mutate(Percentage = n / sum(n)*100)

breeding <- breeding[,-3]

breeding <- spread(breeding, Clusters, Percentage)

colnames(breeding)[1] <- "Category"

Trait <- data.frame(Trait= c(rep("Breeding system", 3)))

Breeding_system <- cbind(Trait, breeding)

##############################################################################################################################
#Compatibility
str(t)
t$IMPUTED_Compatibility <- as.character(t$IMPUTED_Compatibility)
t$IMPUTED_Compatibility[t$IMPUTED_Compatibility=="dioecious"] <- "Self incompatible"
t$IMPUTED_Compatibility[t$IMPUTED_Compatibility=="monoecious"] <- "Self incompatible"
t$IMPUTED_Compatibility[t$IMPUTED_Compatibility=="self_incompatible"] <- "Self incompatible"
t$IMPUTED_Compatibility[t$IMPUTED_Compatibility=="partially_self_compatible"] <- "Partially self compatible"
t$IMPUTED_Compatibility[t$IMPUTED_Compatibility=="self_compatible"] <- "Self compatible"

t$IMPUTED_Compatibility <- factor(t$IMPUTED_Compatibility, levels=c("Self incompatible", "Partially self compatible", "Self compatible"))
#Summary to create table
comp <- t %>%
  group_by(Clusters,IMPUTED_Compatibility) %>%
  summarise (n = n()) %>%
  mutate(Percentage = n / sum(n)*100)

comp <- comp[,-3]

comp <- spread(comp, Clusters, Percentage)
#Replace Na's with zeros
comp[is.na(comp)] <- 0
#Set call name os categories per trait
colnames(comp)[1] <- "Category"
#Create new column
Trait <- data.frame(Trait= c(rep("Compatibility system", 3)))
#Add column
Compatibility_system <- cbind(Trait, comp)
#Bind rows
bind_rows(Breeding_system, Compatibility_system)


############################################################################################################################################
#Life form
t$life_form <- as.character(t$life_form)
t$life_form[t$life_form =="vine"] <- "Shrub"
t$life_form[t$life_form =="tree"] <- "Tree"
t$life_form[t$life_form =="herb"] <- "Herb"
t$life_form[t$life_form =="shrub"] <- "Shrub"
#Order levels
t$life_form <- factor(t$life_form, levels=c("Tree", "Shrub", "Herb"))
#Summary to create table
life_form <- t %>%
  group_by(Clusters,life_form) %>%
  summarise (n = n()) %>%
  mutate(Percentage = n / sum(n)*100)
#delete column to convert to wide
life_form <- life_form[,-3]
#convert to wide
life_form <- spread(life_form, Clusters, Percentage)
#Set call name os categories per trait
colnames(life_form)[1] <- "Category"
#Create new column
Trait <- data.frame(Trait= c(rep("Life form", 3)))
#Add column
Life_form<- cbind(Trait, life_form)
#Bind rows
bind_rows(Breeding_system, Compatibility_system, Life_form)

############################################################################################################################################
t$lifespan <- factor(t$lifespan, levels=c("Perennial","Short lived"))
#Summary to create table
life_span <- t %>%
  group_by(Clusters,lifespan) %>%
  summarise (n = n()) %>%
  mutate(Percentage = n / sum(n)*100)
#delete column to convert to wide
life_span <- life_span[,-3]
#convert to wide
life_span <- spread(life_span, Clusters, Percentage)
#Set call name os categories per trait
colnames(life_span)[1] <- "Category"
#Create new column
Trait <- data.frame(Trait= c(rep("Life span", 2)))
#Add column
Life_span<- cbind(Trait, life_span)
#Bind rows
bind_rows(Breeding_system, Compatibility_system, Life_form, Life_span)

############################################################################################################################################
#t$Flower_morphology <- as.character(t$Flower_morphology)
#t$Flower_morphology[t$Flower_morphology=="Funnelform"] <- "Campanulate"
#t$Flower_morphology[t$Flower_morphology=="Spike"] <- "Brush"
#
#Flower_morphology <- t %>%
#  group_by(Clusters,Flower_morphology) %>%
#  summarise (n = n()) %>%
#  mutate(Percentage = n / sum(n)*100)
##delete column to convert to wide
#Flower_morphology <- Flower_morphology[,-3]
##convert to wide
#Flower_morphology <- spread(Flower_morphology, Clusters, Percentage)
##Set call name os categories per trait
#colnames(Flower_morphology)[1] <- "Category"
##Create new column
#Trait <- data.frame(Trait= c(rep("Flower shape", 6)))
##Add column
#Flower_morphology<- cbind(Trait, Flower_morphology)
##Replace Na's with zeros
#Flower_morphology[is.na(Flower_morphology)] <- 0
##Bind rows
#bind_rows(Breeding_system, Compatibility_system, Life_form, Life_span,Flower_morphology)
#
############################################################################################################################################
t$Flower_symmetry <- as.character(t$Flower_symmetry)
t$Flower_symmetry[t$Flower_symmetry =="actinomorphic"] <- "Actinomorphic"
t$Flower_symmetry[t$Flower_symmetry =="zygomorphic"] <- "Zygomorphic"

Flower_symmetry <- t %>%
  group_by(Clusters,Flower_symmetry) %>%
  summarise (n = n()) %>%
  mutate(Percentage = n / sum(n)*100)
#delete column to convert to wide
Flower_symmetry <- Flower_symmetry[,-3]
#convert to wide
Flower_symmetry <- spread(Flower_symmetry, Clusters, Percentage)
#Set call name os categories per trait
colnames(Flower_symmetry)[1] <- "Category"
#Create new column
Trait <- data.frame(Trait= c(rep("Flower symmetry", 2)))
#Add column
Flower_symmetry<- cbind(Trait, Flower_symmetry)
#Bind rows
bind_rows(Breeding_system, Compatibility_system, Life_form, Life_span,Flower_morphology,Flower_symmetry)
############################################################################################################################################
#t$Autonomous_selfing_level <- as.character(t$Autonomous_selfing_level)
#t$Autonomous_selfing_level[t$Autonomous_selfing_level =="none"] <- "None"
#t$Autonomous_selfing_level[t$Autonomous_selfing_level =="low"] <- "Low"
#t$Autonomous_selfing_level[t$Autonomous_selfing_level =="medium"] <- "Medium"
#t$Autonomous_selfing_level[t$Autonomous_selfing_level =="high"] <- "High"
#
##Order levels
#t$Autonomous_selfing_level <- factor(t$Autonomous_selfing_level, levels=c("High", "Medium", "Low", "None"))
#
#Selfing <- t %>%
#  group_by(Clusters,Autonomous_selfing_level) %>%
#  summarise (n = n()) %>%
#  mutate(Percentage = n / sum(n)*100)
#
##delete column to convert to wide
#Selfing <- Selfing[,-3]
##convert to wide
#Selfing <- spread(Selfing, Clusters, Percentage)
##Set call name os categories per trait
#colnames(Selfing)[1] <- "Category"
##Create new column
#Trait <- data.frame(Trait= c(rep("Selfing level", 2)))
##Replace Na's with zeros
#Selfing[is.na(Selfing)] <- 0
##Add column
#Selfing_1 <- cbind(Trait, Selfing)
##Bind rows
#bind_rows(Breeding_system, Compatibility_system, Life_form, Life_span,Flower_morphology, Selfing_1)
#
#############################################################################################################################################
t$Nectar_presence_absence <- as.character(t$Nectar_presence_absence)
t$Nectar_presence_absence[t$Nectar_presence_absence =="yes"] <- "Yes"
t$Nectar_presence_absence[t$Nectar_presence_absence =="no"] <- "No"

Nectar <- t %>%
  group_by(Clusters,Nectar_presence_absence) %>%
  summarise (n = n()) %>%
  mutate(Percentage = n / sum(n)*100)

#delete column to convert to wide
Nectar <- Nectar[,-3]
#convert to wide
Nectar <- spread(Nectar, Clusters, Percentage)
#Set call name os categories per trait
colnames(Nectar)[1] <- "Category"
#Create new column
Trait <- data.frame(Trait= c(rep("Nectar", 2)))
#Replace Na's with zeros
Nectar[is.na(Nectar)] <- 0
#Add column
Nectar <- cbind(Trait, Nectar)
#Bind rows
data <- bind_rows(Breeding_system, Compatibility_system, Life_form, Life_span, Flower_symmetry, Nectar)

#remove first col
data_1 <- data[,-1]
colnames(data_1) <- c("Category", "Cluster 1", "Cluster 2", "Cluster 3", "Cluster 4", "Cluster 5")

#transpose dataframe
data_2 <- as.data.frame(t(data_1))

#rownames to colnames (1st one)
data_3 <- data_2 %>% row_to_names(row_number = 1)

#Convert all variables to numeric
data_4 <- sapply(data_3, function(x) as.numeric(as.character(x)))

#set back the missed rownames in the processing
rownames(data_4) <- rownames(data_3)

# Convert to dataframe
data_4 <- as.data.frame(data_4)

# Scale values and set rowname as column
data_5 <-data_4 %>% rownames_to_column( var = "group" )


data_6 <- melt(data_5)

cluster1 <- subset(data_6, group=="Cluster 1")

cluster1$traits <- c(rep("Breeding system",3), rep("Compatibility",3), rep("Life form",3),
                     rep("Life span",2), rep("Flower symmetry",2), rep("Nectar",2))


#Try to achieve the desire output with plot_grid

c1 <- cluster1 %>% 
  ggplot(aes(x = variable,  y = value, fill = group))  +  
  geom_col(position = "dodge") +   scale_fill_manual(name = NULL,values="#00AFBB")+
  facet_grid(~traits, scales = "free_x", space = "free_x")+theme_bw()+
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank())+scale_y_continuous(expand = c(0,0)) +
  theme(axis.title.x = element_blank(), axis.text.x=element_blank(),plot.title = element_text(size = 18))+ ylab("")+
  ggtitle("A) Qualitative variables")


cluster2 <- subset(data_6, group=="Cluster 2")

cluster2$traits <- c(rep("Breeding system",3), rep("Compatibility",3), rep("Life form",3),
                     rep("Life span",2), rep("Flower symmetry",2), rep("Nectar",2))

c2 <- cluster2 %>% 
  ggplot(aes(x = variable,  y = value, fill = group))  +  
  geom_col(position = "dodge") +   scale_fill_manual(name = NULL,values="#E69F00")+
  facet_grid(~traits, scales = "free_x", space = "free_x")+theme_bw()+
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank())+scale_y_continuous(expand = c(0,0)) +
  theme(strip.background = element_blank(), strip.text = element_blank())+
  theme(axis.title.x = element_blank(), axis.text.x=element_blank())+ylab("")



cluster3 <- subset(data_6, group=="Cluster 3")

cluster3$traits <- c(rep("Breeding system",3), rep("Compatibility",3), rep("Life form",3),
                     rep("Life span",2), rep("Flower symmetry",2), rep("Nectar",2))

c3 <- cluster3 %>% 
  ggplot(aes(x = variable,  y = value, fill = group))  +  
  geom_col(position = "dodge") +   scale_fill_manual(name = NULL,values="#FC4E07")+
  facet_grid(~traits, scales = "free_x", space = "free_x")+theme_bw()+
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank())+scale_y_continuous(expand = c(0,0)) +
  theme(axis.title.x = element_blank(), axis.text.x=element_blank())+
  theme(strip.background = element_blank(), strip.text = element_blank())+ylab("Percentage")


cluster4 <- subset(data_6, group=="Cluster 4")

cluster4$traits <- c(rep("Breeding system",3), rep("Compatibility",3), rep("Life form",3),
                     rep("Life span",2), rep("Flower symmetry",2), rep("Nectar",2))

c4 <- cluster4 %>% 
  ggplot(aes(x = variable,  y = value, fill = group))  +  
  geom_col(position = "dodge") +   scale_fill_manual(name = NULL,values="#000000")+
  facet_grid(~traits, scales = "free_x", space = "free_x")+theme_bw()+
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank())+scale_y_continuous(expand = c(0,0)) +
  theme(axis.title.x = element_blank(), axis.text.x=element_blank())+
  theme(strip.background = element_blank(), strip.text = element_blank())+ylab("")




cluster5 <- subset(data_6, group=="Cluster 5")

cluster5$traits <- c(rep("Breeding system",3), rep("Compatibility",3), rep("Life form",3),
                     rep("Life span",2), rep("Flower symmetry",2), rep("Nectar",2))
c5 <- cluster5 %>% 
  ggplot(aes(x = variable,  y = value, fill = group))  +  
  geom_col(position = "dodge") +   scale_fill_manual(name = NULL,values="darkgreen")+
  facet_grid(~traits, scales = "free_x", space = "free_x")+theme_bw()+
  scale_y_continuous(expand = c(0,0)) +
  theme(axis.text.x = element_text(angle = 45,vjust = 1, hjust=1))+
  theme(strip.background = element_blank(), strip.text = element_blank())+ylab("")+xlab("")

A <- c1 + c2 + c3 + c4 + c5 + plot_layout(ncol = 1)
B <- ggradar(final_df_3, group.colours=c("#00AFBB", "#E69F00", "#FC4E07","#000000", "darkgreen"),
             legend.text.size=5, grid.label.size = 0,legend.position = "none",axis.label.size=3)+ 
  guides(shape = guide_legend(override.aes = list(size = 0.5)))+ ggtitle("B) Quantitative variables")+
  theme(plot.title = element_text(size = 18))

patch <- A | B 

patch + plot_annotation(title = "Plant functional groups",theme = theme(plot.title = element_text(size = 20,face="bold")))

```
