---
title: Plant-pollintor networks worldwide are composed by the same specific building
  blocks
output:
  html_document: default
  pdf_document: default
editor_options:
  chunk_output_type: console
bibliography: bibliography.bib
header-includes:
- \usepackage{booktabs}
- \usepackage{longtable}
- \usepackage{array}
- \usepackage{multirow}
- \usepackage{wrapfig}
- \usepackage{float}
- \usepackage{colortbl}
- \usepackage{pdflscape}
- \usepackage{tabu}
- \usepackage{threeparttable}
- \usepackage{threeparttablex}
- \usepackage[normalem]{ulem}
- \usepackage{makecell}
- \usepackage{xcolor}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

##Abstract

Ecological processes leave distinct structural imprints on species interactions shaping  the topology of mutualistic networks. Detecting those relationships is not trivial since they go beyond pair-wise interactions, but may get blurred when considering full network descriptors. However, recent work has shown the network meso-scale can capture this important information. The meso-scale describes network subgraphs representing patterns of interactions between a small number of species (i.e. motifs) and those constitute the building blocks of the whole network. Here we have compiled 60 networks from 18 different studies and show that some motifs are consitently over-represented worldwide, suggesting that the building blocks of plant-pollintor networks are not random and are associated to ... Second, we show that the position of pollinator guilds and plant reproductive strategies is not random with respect to the positions occupied within each motif. ... Hence, we show that species ecology is shaping the building blocks that conform the web of life.

##INTRODUCTION

The interaction between plants and pollinators can be studied at different scales, from species level interactions (micro-scale) to the full network structure (macro-scale). Research of the network structure have proven common invariant structural properties across them including a degree distribution that decays as a power law [@jordano1987], nestedness [@bascompte2003], or the higher number of pollinator species than plant species [@bluthgen2007]. In addition, species phenological overlap, morphological matching and species abundances have been shown to be determinant for the understanding of pairwise plant-pollinator interactions [@bartomeus2016; @stang2006; @peralta2020]. However, both species level information or an holistic view of the full network involves missing relevant information for the understanding of ecological processes [@simmons2019]. 

Indirect interactions (i.e., motifs), commonly referred as the building blocks that depict subsets of interactions of the network [@milo2002], are a widespread phenomenon in ecological communities [@strauss1991]. For instance, plant species can facilitate or compete for pollinator's visitation when two species are visited by the same pollinator [@ghazoul2006]. Despite the relevance of indirect interactions in ecological communities, plant-pollinator research often fails to finely capture those indirect interactions with the traditional analytical tools that condense the information either by species (e.g. interaction frequency) or in single topological indices (e.g. nestedness). Nonetheless, the emerging framework of network motifs in plant-pollinator research allows to consider both direct and indirect interactions [@simmons2019]. The study of @simmons2020 have shown that the different processes that govern species interactions (e.g., species abundances versus trait-matching) can lead to different patterns of indirect interactions. However, we still ignore which are the general patterns observed in the distribution of plant-pollinator motifs worldwide.

Motifs are abstract representations often decoupled from species ecology. Hence, linking the structural properties of the meso-scale with the species ecology can help the understanding of ecological processes. For instance, different motifs can have different ecological meanings [@simmons2019] and the position within a motif can determine the species functional role [@stouffer2012; @baker2015]. However, it is unclear if species ecological and life history traits strongly determines its role within the network of interactions [@coux2016]. For example, bees are more specialized foragers [Jose, aquí por ejemplo, pueden decir que abejas pequeñas y generalistas, pueden comportarse muy diferente que grandes y especialistas... si tienes una lista de pollintors, con su familia, pasamela, y le hecho un ojo](), usually alble to open complex zygomorphic flowers which are not accessible to fly pollinators. How this different behaviors translate into their interaction topology is unknown. Similarly, recent empirical findings indicate that the meso-scale is the best descriptor of plant reproductive success [@allen2021], but little is known on how plants reproductive strategies shape their position within the network of interactions. Although some studies have evaluated plant reproductive strategies in plant-pollinator networks [@tur2013; @lazaro2020], they are often overlooked in a community context [@devaux2014] and rarely incorporated into plant-pollinator network studies. Hence, exploring how the main plant reproductive strategies integrate with the emergent motif framework can shed light on key aspects of ecosystem functioning. 

Here, we used 60 plant-pollinator networks from 18 different studies distributed worldwide, alongside a detailed grouping of plants into reproductive strategies and pollinator species into functional groups. Plants were grouped based on a comprehensive dataset that included floral, reproductive and vegetative traits compiled in Lanuza et al., (unpublished) on a larger set of plant-pollinator networks. Pollinators were grouped into the main taxonomical groups that differed in life form and behaviour. Then, we explored which motifs up to five nodes in these set of plant-pollinator networks were over and under-represented. Finally, we explore if the different plants and pollinators functional groups are over- or under-represented in certain positions.

##METHODS

**Plant-pollinator studies**

We have compiled 60 plant-pollinator networks from 18 different studies (Table S1). All studies sampled plant-pollinator interactions in natural systems and were selected based on wide geographical coverage and the presence of interaction frequency as a measure of interaction strength. In total, there were 503 plant species, 1,111 pollinator species and 6248 of pairwise interactions registered. For ease of data manipulation plant and pollinator species names were standardize with the help of the package taxize version 0.9.99 [@chamberlain2020].

**Plant and pollinator functional groups**

First, plant species were grouped into the optimal number of functional groups that summarized the main plant reproductive strategies. This was done with the help of hierarchical cluster analysis by using the trait dataset collated in Lanuza et al., (unpublished) that comprised 1,506 plant species and contained the same 60 plant-pollinator networks used in this study plus some non-weighted and weighted metawebs (see Table S1 Lanuza et al., unpublished). This dataset consisted on 8 floral, 4 reproductive and 3 vegetative traits (Table S2). We opted to calculate the plant functional groups on this larger set of species because of the higher accuracy when delimiting the functional groups with that many variables @dolnicar2014. For this, we calculated the distance of the different functional traits with the function gowdis from the package FD version 1.0-12 [@laliberte2014] with the method ward.D2 used for non-squared distances [@murtagh2014]. All the numerical traits were previously scaled. Finally, we applied a hierarchical cluster analysis with the function hclust from the R stats package version 4.0.5 and calculated the optimal number of clusters with the function kgs from the package maptree version 1.4-7 [@white2009].

Second, pollinators were grouped into functional groups based on taxonomic rank. We opted to divide pollinators on the taxonomic rank level and not with functional traits because (i) they main taxonomic orders differ in form and behaviour and (ii) the lower complexity of higher taxonomic ranks (i.e., pollinators had 6 orders versus plants that had 38). Hence, we grouped pollinators into 6 functional groups: (i) Hymenoptera-Anthophila (bees), (ii) Hymenoptera-non-Anthophila (other non-bee Hymenoptera), (iii) Syrphidae-Diptera, (iv) non-Syrphidae-Diptera, (v) Lepidoptera and (vi) Coleoptera. 


**Meso-scale analysis**

Following Simmons et al. [@simmons2019; @simmons2020], we broke down the plant-pollinator networks into their constituent motifs. Prior to analyses, we selected only robust links, that is, interactions whose frequency was greater than one (64.98 % interactions); and, then, we turned the quantitative networks into qualitative (or binary) ones, where interactions are present or absent. [Here I would present maybe full analysis, and without singletones in sup mat, especially if they are consistent]()

We calculated the frequency of all motifs up to five nodes (see Figure 1) for each empirical network, by using the ‘bmotif’ package [@bmotifsimmons2019]. To control for variation in network size and for the fact that smaller motifs can be nested within larger motifs, the frequencies were normalised as a proportion of the total number of motifs within each motif class (i.e., the number of nodes a motif contains). Like [@simmons2020], we just used five-node motifs in our analyses for visualisation, interpretation and computational reasons. In addition, we also excluded two-node motifs (or links) from our analyses because their normalised frequencies would always equal one.


```{r, echo=FALSE, message=FALSE, cache=FALSE,  warning=FALSE, fig.cap="Figure 1. Adapted figure of Simmons et al., 2019 with all the possible motifs from two to five species in bipartite networks. There is a total of 17 possible motifs with 46 different positions denoted within each node.", fig.width=10,fig.height=8}
library(tidyverse)
library(RColorBrewer)
source("../Scripts/Scripts_Alfonso/plot_motif_positionsV2.R")

motif_number <- 1
p1 <- plot_motif_positions(motif_number)

motif_number <- 2
p2 <- plot_motif_positions(motif_number)

motif_number <- 3
p3 <- plot_motif_positions(motif_number)

motif_number <- 4
p4 <- plot_motif_positions(motif_number)

motif_number <- 5
p5 <- plot_motif_positions(motif_number)

motif_number <- 6
p6 <- plot_motif_positions(motif_number)

motif_number <- 7
p7 <- plot_motif_positions(motif_number)

motif_number <- 8   
p8 <- plot_motif_positions(motif_number)

motif_number <- 9
p9 <- plot_motif_positions(motif_number)

motif_number <- 10
p10 <- plot_motif_positions(motif_number)

motif_number <- 11
p11 <- plot_motif_positions(motif_number)

motif_number <- 12
p12 <- plot_motif_positions(motif_number)

motif_number <- 13
p13 <- plot_motif_positions(motif_number)

motif_number <- 14
p14 <- plot_motif_positions(motif_number)

motif_number <- 15
p15 <- plot_motif_positions(motif_number)

motif_number <- 16
p16 <- plot_motif_positions(motif_number)

motif_number <- 17
p17 <- plot_motif_positions(motif_number)


library(patchwork)

(p1 & ylab("2 species")| p2 & ylab("3 species") | p3 )/ (p4 & ylab("4 species")| p5 | p6 | p7)/ (p8  & ylab("5 species")| p9 | p10 | p11 | p12) / (p13 & ylab("5 species")| p14 | p15 | p16 | p17) & theme(axis.title.y = element_text(color="black", size=14, face="bold")) #+
 #plot_annotation(tag_levels = '1') 

```


To assess the significance of the observed frequencies, we created 1,000 simulated networks for each binary network using the ‘nullmodel’ function and the ‘vaznull’ model in the bipartite package [@dormann2009]. Generated networks had the same number of plants and pollinators, as well as the same connectance of their corresponding empirical networks. After extracting the motif frequencies from the simulated networks, for each motif type and empirical network, we calculated the percentage of simulated networks whose frequencies were smaller than the ones observed, that is, we estimated the percentile of the observed motif frequencies. Motifs whose percentile is close to zero or 100 are under- or over-represented in the empirical networks, respectively, and, thus, they cannot be predicted by connectance and the number of species alone. To summarize general patterns across networks, we used an intercept-only linear mixed model (LMM) per motif, where the response variable was the observed motif percentile per network. In these models, we used the study identifiers in Table S1 as a random intercept. By doing so, we obtained estimates of the average motif frequency, in which we controlled the variation at the study level. 

Next, we calculated which functional groups were over or under-represented in different motif positions by comparing position frequencies of empirical networks with those of their corresponding simulated counterparts. We extracted the position frequencies of all motifs from three to five nodes for each network and species by using the ‘bmotif’ package [@bmotifsimmons2019]. To estimate the position frequencies of each functional group in a given network, we added the frequencies of those species that belong to the group, and then, we normalised the resulting frequencies by dividing the position measure for each group by the total number of times that a group appears in any position within the same motif size class. Then, we calculated the percentile of the observed position frequencies for each group and network, just like we did motif frequencies. To outline the general patterns of position frequencies across networks and functional groups, we fit a LMM per motif position, where the response variable was the observed position percentile per network. We used the functional group identifier as an explanatory variable and the study identifiers as a random intercept. By adding the functional group estimates to the model intercept, we assessed the average motif frequency, after controlling the variation at the study level. To fit the LMMs models in our analyses, we used the ‘lmer’ package [@bates2015].

[potential additions: 
Finally,for each motif, we recover the number of times a given combination of functional groups emerges ...]

##RESULTS

**Functional groups**

The hierarchical cluster analysis divided the dataset with 1506 species and 15 traits into five different clusters with different and overlapping characteristics (Figure S1). The subset of plant species used in this study (N = 503) were distributed evenly across these different larger five groups (see Figure S1). The first cluster "short-lived selfers"





The first and largest cluster, Cluster A, was constituted by 710 species. The species of this cluster had the shortest plant heights (Median = 0.5m, Mean = 0.84m), were mostly herbs (89.58%) with short lived life span (68.23%) and the lowest number of flowers per plant (Median = 30, Mean = 197.15); the flowers were mostly hermaphrodite (97.40%) with actinomorphic symmetry (99.48%), the morphology was variant but the predominant shapes were ‘open’ (51.56%) and ‘capitulum’ (23.44%); most of the species were self compatible (96.35%) and had the higher levels of autonomous selfing of all clusters from low-medium selfing (47.92%) to high selfing (52.08%) with nectar production for 83.85% of the species. Cluster B, had 588 species and was the the second in plant height (Median = 0.8m, Mean = 1.98m), number of flowers per plant (Median = 75; Mean = 1559) and flowers per inflorescence (Median = 15; Mean = 58), it had diverse life forms (herbs 52.89%, shrubs 34.52% and trees 12.59%) and the species were mostly perennial (97.96%); the flowers were the second largest (flower length Median = 10mm, Mean = 10.08mm; flower width Median = 5.10mm, Mean = 16.88mm) and it had mostly hermaphroditic breeding system (95.41%), actinomorphic symmetry (99.15%) and a predominant flower morphology of ‘open’ (50.17%) and ‘tube’ shapes (20.07); the majority of species were self compatible (70.24%) and partially self compatible (20.24%) and had low selfing levels (88.95%) with nectar production for 78.40%. Cluster C was constituted by 323 species, had similar plant heights to cluster B (Median = 0.75, Mean = 1.85) with also diverse life forms (61.61% herbs, 28.79% shrubs, 9.60% trees) with mostly perennial species (95.36%) with the largest flower size (flower length Median =9.10mm , Mean =13.95mm; flower width Median =15mm, Mean =20.18mm) and number of ovules per flower of all clusters (Median = 30, Mean  = 527.87); flowers were mostly hermaphroditic (97.83%) with actinomorphic flowers (78.95%) and predominant ‘open’ (28.48%) ‘capitulum’ (27.55%) and ‘tube’ (26.01%) flower morphology; this was the cluster with greater proportion of self incompatible species (76.47%) and it had negligible autonomous selfing level (Median = 0,  Mean = 0.30) with the highest proportion of nectar secreting species (92.26%). Cluster D had 164 species, they were the tallest plants (Median =2.88m, Mean =5.19m) and had the largest proportion of shrubs (41.46%) and trees (31.71%) of all clusters, the species were mainly perennial (92.07%) and differentiated from the rest of the clusters by having principally dioecious (63.41%) and monoecious (35.98%) breeding system; this cluster had the largest number of flower per plant (Median = 1000, Mean = 6803) and per inflorescence (Median = 30 , Mean = 258) but the smaller flower size of all clusters (flower length Median =2.71, Mean =6.53; flower width Median = 3.62; Mean = 8.23) with ‘open’ (53.66%) and ‘brush’ (21.34%) morphology as the most representative flower shapes of this group; in addition, this cluster had the shortest styles (Median = 1mm; Mean = 3.05mm) and lower number of ovules (Median = 4.50, Mean = 110.47) along with cluster A; thus, the flowers were unisexual (98.78%), actinomorphic (95.12%), had no selfing (98.17%) and had the lowest proportion of nectar secreting species (69.51%) of all clusters. Finally, 239 species integrated Cluster E which had the second shortest species of all clusters (Median = 0.55m; Mean = 1.23m), the species were mainly herbs (83.26%) and perennial (70.29%) but also had a representative proportion of short lived species (29.71%); this cluster was the only one with mainly zygomorphic flowers (97.07%) with tubular (55.65%) and papilionaceous (24.69%) flower shapes, the species had mostly hermaphroditic breeding system (96.65%) and the flowers had the longest styles of all clusters (Median = 5mm; Mean = 8.74mm); species were mostly self compatible (88.28%) and nectar secreting (88.28%) with low autonomous selfing levels (61.92%) but also had species with high (18.41%) medium (15.06%) and lack of autonomous selfing (4.60%).

Figure S1

**Overall meso-scale patterns**

```{r, echo=FALSE, message=FALSE, cache=FALSE,  warning=FALSE, fig.cap="Figure 2. Comparison of the motif frequencies between empirical and simulated networks. Average percentages of motifs close to 0 and 100 indicate under- and over- representation in empirical networks. The different motifs are coloured by the mean path length as done in @simmons2020.", fig.width=9,fig.height=5}
library(lme4)
library(nlme)
library(tidyverse)
source("../Scripts/Scripts_Alfonso/add_study_id.R")
d <- read_csv("../Data/Csv/Motifs_frequencies_and_null_models/Motifs_frequency_percentile.csv")
d <- add_study_id(d)
#str(d)
#head(d)

#ggplot(d %>% filter(motif != 1), aes(percentil_sizeclass))+
#  geom_histogram(color="black", fill="white")+
#  facet_wrap(~motif)+
#  theme_bw()+
#  labs(x="Sizeclass percentile")
#
# Motifs tend to be over- and under-represensented in real networks

# Mean percentile and SE taking into account the study system
motif_codes <- d %>% filter(motif != 1) %>% # We remove links (motif code: 1)
  select(motif) %>% unique() %>% pull()
motif_means <- tibble(motif = motif_codes)
motif_means$mean <- NA
motif_means$SE <- NA

for(i.motif in 1:length(motif_codes)){
  
  m <- lmer(percentil_sizeclass ~ 1+(1|study_id), #HERE WE NEED STUDY SYSTEM ONLY!! 
            data = subset(d, motif == motif_codes[i.motif]))  
  
  motif_means$mean[i.motif] <- fixed.effects(m) %>% unname()
  motif_means$SE[i.motif] <- sqrt(diag(vcov(m)))
  
}

#Add categories based on path length set by Simmons 2021 et al., Functional Ecology
d$Broad_categories[d$motif==2 | d$motif==7 | d$motif==17 | d$motif==3|d$motif==4|d$motif==8] <- "Fan" 

d$Broad_categories[d$motif==15 | d$motif==11] <- "Medium-weak" 

d$Broad_categories[d$motif==6 | d$motif==16 |  d$motif==12] <- "Strong" 

d$Broad_categories[d$motif==5 | d$motif==9 |  d$motif==14|  d$motif==13|  d$motif==10] <- "Weak" 

#order the categories from short to long path length
d$Broad_categories <- factor(d$Broad_categories, levels = c("Strong", "Fan", "Medium-weak", "Weak"))

ggplot(NULL) + 
  geom_point(data = d %>% filter(motif != 1),
             aes(y=as.factor(motif), x=100*percentil_sizeclass, 
                 color = as.factor(Broad_categories)),
             position = "jitter",alpha=0.5)+
  geom_errorbar(data = motif_means,aes(y = as.factor(motif), xmin=100*(mean-SE), xmax=100*(mean+SE)), 
                width=1.0,size=1)+
  geom_point(data = motif_means,aes(y = as.factor(motif), x=100*mean), 
                size=2)+
  labs(y="Motif", x = "Percentile (%)",colour="Path length classification")+
  theme_bw() + scale_color_manual(labels = c('Strong' = expression(paste("Complete (", bar(x), " = 1.38)")),'Fan' = expression(paste("Fan (", bar(x), " = 1.48)")), 'Medium-weak' = expression(paste("Asymmetric complete (", bar(x), " = 1.60)")), "Weak" =expression(paste("Core-peripheral (", bar(x), " = 1.85)"))), name = "Path length classification",values = c("grey25","springgreen4","sienna2","goldenrod2"),guide = guide_legend(title.position = "top",nrow = 2)) +
theme(legend.text.align = 0)+
  theme(legend.position="bottom")

#Trying to maintain a gradient from low to high in colors

#Fig 1 Should be a dot plot (or forest plot) of the mean +- SE of the 15 motifs.
#NICE! Can we put motifs in Y axes, and % in X?
```

**Meso-scale functional groups position**

```{r, echo=FALSE, message=FALSE, cache=FALSE,  warning=FALSE,fig.align = 'center',fig.width=6,fig.height=3.5}
library(lme4)
library(nlme)
library(tidyverse)
library(stringi)
library(ggpubr)
source("../Scripts/Scripts_Alfonso/add_study_id.R")

all_position_percentiles <- read_csv("../Data/Csv/Motifs_positions_and_null_models/GF_positions_frequency_percentile.csv")

all_position_percentiles$position <- stri_extract_first_regex(all_position_percentiles$position,
                                                              "[0-9]+") %>% as.numeric()

all_position_percentiles <- add_study_id(all_position_percentiles)
#str(all_position_percentiles)
#head(all_position_percentiles)

list_plants_FG <- as.character(1:10)

plant_position_percentiles_filtered <- all_position_percentiles %>% 
  filter(Node_FG %in% list_plants_FG, !position %in% c(1,2),
         !is.na(expected_freq_its_GF)) #ME DA ERROR
pollinator_position_percentiles_filtered <- all_position_percentiles %>% 
  filter(!Node_FG %in% list_plants_FG, !position %in% c(1,2),
         !is.na(expected_freq_its_GF))

#ggplot(plant_position_percentiles_filtered, aes(percentil_its_GF))+
#  geom_histogram(color="black", fill="white")+
#  facet_wrap(~position)+
#  theme_bw()+
#  labs(x="Sizeclass percentile", title = "Histograms: Percentiles for plant positions")
#
#ggplot(pollinator_position_percentiles_filtered, aes(percentil_its_GF))+
#  geom_histogram(color="black", fill="white")+
#  facet_wrap(~position)+
#  theme_bw()+
#  labs(x="Sizeclass percentile",title = "Histograms: Percentiles for pollinator positions")
#


# estimated mean taking into account the random str is 0.XX +- 0.XX (look at the (Intercept) estimate)


# Plants-------------

# Mean percentile and SE taking into account the study system
plant_codes <- plant_position_percentiles_filtered$position %>% unique()
plant_means <- plant_position_percentiles_filtered %>% select(position,Node_FG) %>% unique()
plant_means$mean <- NA
plant_means$SE <- NA


for(i.pos in 1:length(plant_codes)){
  
  m <- lmer(percentil_its_GF ~ Node_FG + (1|study_id),
            data = plant_position_percentiles_filtered %>%
                          filter(position == plant_codes[i.pos]))  
  
  temp <- fixed.effects(m) %>% unname()
  plant_means$mean[plant_means$position == plant_codes[i.pos]] <- c(temp[1],
                                                                     temp[1]+temp[2],
                                                                     temp[1]+temp[3],
                                                                     temp[1]+temp[4],
                                                                     temp[1]+temp[5]) ## to get real means per FG
  temp <- sqrt(diag(vcov(m)))
  plant_means$SE[plant_means$position == plant_codes[i.pos]] <- c(temp[1], 
                                                                  temp[1]+temp[2],
                                                                  temp[1]+temp[3],
                                                                  temp[1]+temp[4],
                                                                  temp[1]+temp[5])
  
}

GF_plant_pos <- ggplot(NULL) + 
  geom_point(data = plant_position_percentiles_filtered,
             aes(x=as.factor(position), y=percentil_its_GF, 
                 color = as.factor(position)),
             position = "jitter",alpha=0.5)+
  geom_errorbar(data = plant_means,aes(x = as.factor(position), ymin=mean-SE, ymax=mean+SE), 
                width=1.0,size=1)+
  facet_wrap(~Node_FG,ncol = 5)+
  geom_point(data = plant_means,aes(x = as.factor(position), y=mean), 
             size=2)+
  labs(x="Position", y = "Percentile",title = "Plants")+
  theme_bw()+
  theme(legend.position = "none")+#,axis.text.x=element_text(angle=90,vjust=0.5, hjust=1))+
  coord_flip()


# Pollinators--------

# Mean percentile and SE taking into account the study system
pollinator_codes <- pollinator_position_percentiles_filtered$position %>% unique()
pollinator_means <- pollinator_position_percentiles_filtered %>% select(position,Node_FG) %>% unique()
pollinator_means$mean <- NA
pollinator_means$SE <- NA
pollinator_means_reordered <- NULL

for(i.pos in 1:length(pollinator_codes)){
  
  m <- lmer(percentil_its_GF ~ Node_FG + (1|study_id), #HERE WE NEED STUDY SYSTEM ONLY!! 
            data = pollinator_position_percentiles_filtered %>%
                          filter(position == pollinator_codes[i.pos]),
            control = lmerControl(optimizer ="Nelder_Mead")) # I changed the optimizer because motif 8 (i.pos = 3) caused convergence problems, max gradient = 0.0022 > 0.002.
  
  temp <- fixed.effects(m) %>% unname()
  pollinator_means_aux <- pollinator_means[pollinator_means$position == pollinator_codes[i.pos],] %>% arrange(Node_FG)
  
  pollinator_means_aux$mean <- c(temp[1],
                                 temp[1]+temp[2],
                                 temp[1]+temp[3],
                                 temp[1]+temp[4],
                                 temp[1]+temp[5],
                                 temp[1]+temp[6],
                                 temp[1]+temp[7],
                                 temp[1]+temp[8],
                                 temp[1]+temp[9]) ## to get real means per FG
    
                                                                    
  temp <- sqrt(diag(vcov(m)))
  pollinator_means_aux$SE <- c(temp[1],
                               temp[1]+temp[2],
                               temp[1]+temp[3],
                               temp[1]+temp[4],
                               temp[1]+temp[5],
                               temp[1]+temp[6],
                               temp[1]+temp[7],
                               temp[1]+temp[8],
                               temp[1]+temp[9])
  
  pollinator_means_reordered <- bind_rows(pollinator_means_reordered,pollinator_means_aux)
    
}

# There are lower limits (mean - SE) smaller than 0 (see Other insects)
# We set the lower limit of those error bars to zero

pollinator_means_reordered <- pollinator_means_reordered %>% mutate(lower = mean-SE)
pollinator_means_reordered$lower[pollinator_means_reordered$lower < 0] <- 0

GF_poll_pos <- ggplot(NULL) + 
  geom_point(data = pollinator_position_percentiles_filtered,
             aes(x=as.factor(position), y=percentil_its_GF, 
                 color = as.factor(position)),
             position = "jitter",alpha=0.5)+
  geom_errorbar(data = pollinator_means_reordered, aes(x = as.factor(position), ymin=lower,
                                                       ymax=mean+SE), 
                width=1.0,size=1)+
  facet_wrap(~Node_FG,ncol = 5)+
  geom_point(data = pollinator_means_reordered,aes(x = as.factor(position), y=mean), 
             size=2)+
  labs(x="Position", y = "Percentile", title = "Pollinators")+
  theme_bw()+
  theme(legend.position = "none")+#,axis.text.x=element_text(angle=90,vjust=0.5, hjust=1))+
  coord_flip()


# Plant and Pollinators--------
#
#ggarrange(GF_plant_pos,GF_poll_pos,
#          ncol = 1, nrow = 2,heights = c(.90, 1.4))
#
#Fig 2 may be the same, but for the each positions-FG combination? Maybe heatmap (but we lose the SE's)

```


```{r, echo=FALSE, message=FALSE, cache=FALSE,  warning=FALSE, fig.height=8,fig.width=8,fig.align = 'center', fig.cap="Figure 3. Heatmap indicating under- and over- representation of pollinator and plant functional groups in the different motif positions. The different motif positions are dividied by the average path length clasification by @simmons2020."}

library(lme4)
library(nlme)
library(tidyverse)
library(stringi)
source("../Scripts/Scripts_Alfonso/add_study_id.R")

#############################################
# EXTRACT MEAN VALUES
#############################################


all_position_percentiles <- read_csv("../Data/Csv/Motifs_positions_and_null_models/GF_positions_frequency_percentile.csv")

all_position_percentiles$position <- stri_extract_first_regex(all_position_percentiles$position,
                                                              "[0-9]+") %>% as.numeric()

all_position_percentiles <- add_study_id(all_position_percentiles)
#str(all_position_percentiles)
#head(all_position_percentiles)

list_plants_FG <- as.character(1:10)

plant_position_percentiles_filtered <- all_position_percentiles %>% 
  filter(Node_FG %in% list_plants_FG, !position %in% c(1,2),
         !is.na(expected_freq_its_GF)) #ME DA ERROR
pollinator_position_percentiles_filtered <- all_position_percentiles %>% 
  filter(!Node_FG %in% list_plants_FG, !position %in% c(1,2),
         !is.na(expected_freq_its_GF))


# Plants-------------

# Mean percentile and SE taking into account the study system
plant_codes <- plant_position_percentiles_filtered$position %>% unique()
plant_means <- plant_position_percentiles_filtered %>% select(position,Node_FG) %>% unique()
plant_means$mean <- NA
plant_means$SE <- NA


for(i.pos in 1:length(plant_codes)){
  
  m <- lmer(percentil_its_GF ~ Node_FG + (1|study_id),
            data = plant_position_percentiles_filtered %>%
              filter(position == plant_codes[i.pos]))  
  
  temp <- fixed.effects(m) %>% unname()
  plant_means$mean[plant_means$position == plant_codes[i.pos]] <- c(temp[1],
                                                                    temp[1]+temp[2],
                                                                    temp[1]+temp[3],
                                                                    temp[1]+temp[4],
                                                                    temp[1]+temp[5]) ## to get real means per FG
  temp <- sqrt(diag(vcov(m)))
  plant_means$SE[plant_means$position == plant_codes[i.pos]] <- c(temp[1], 
                                                                  temp[1]+temp[2],
                                                                  temp[1]+temp[3],
                                                                  temp[1]+temp[4],
                                                                  temp[1]+temp[5])
  
}


# Pollinators--------

# Mean percentile and SE taking into account the study system
pollinator_codes <- pollinator_position_percentiles_filtered$position %>% unique()
pollinator_means <- pollinator_position_percentiles_filtered %>% select(position,Node_FG) %>% unique()
pollinator_means$mean <- NA
pollinator_means$SE <- NA
pollinator_means_reordered <- NULL

for(i.pos in 1:length(pollinator_codes)){
  
  m <- lmer(percentil_its_GF ~ Node_FG + (1|study_id), #HERE WE NEED STUDY SYSTEM ONLY!! 
            data = pollinator_position_percentiles_filtered %>%
              filter(position == pollinator_codes[i.pos]),
            control = lmerControl(optimizer ="Nelder_Mead")) # I changed the optimizer because motif 8 (i.pos = 3) caused convergence problems, max gradient = 0.0022 > 0.002.
  
  temp <- fixed.effects(m) %>% unname()
  pollinator_means_aux <- pollinator_means[pollinator_means$position == pollinator_codes[i.pos],] %>% arrange(Node_FG)
  
  pollinator_means_aux$mean <- c(temp[1],
                                 temp[1]+temp[2],
                                 temp[1]+temp[3],
                                 temp[1]+temp[4],
                                 temp[1]+temp[5],
                                 temp[1]+temp[6],
                                 temp[1]+temp[7],
                                 temp[1]+temp[8],
                                 temp[1]+temp[9]) ## to get real means per FG
  
  
  temp <- sqrt(diag(vcov(m)))
  pollinator_means_aux$SE <- c(temp[1],
                               temp[1]+temp[2],
                               temp[1]+temp[3],
                               temp[1]+temp[4],
                               temp[1]+temp[5],
                               temp[1]+temp[6],
                               temp[1]+temp[7],
                               temp[1]+temp[8],
                               temp[1]+temp[9])
  
  pollinator_means_reordered <- bind_rows(pollinator_means_reordered,pollinator_means_aux)
  
}

# There are lower limits (mean - SE) smaller than 0 (see Other insects)
# We set the lower limit of those error bars to zero

pollinator_means_reordered <- pollinator_means_reordered %>% mutate(lower = mean-SE)
pollinator_means_reordered$lower[pollinator_means_reordered$lower < 0] <- 0

#############################################
# ADDING BROAD MOTIF CATEGORIES TO POSITIONS
#############################################

motifs_raw_data <- read_csv("../Data/Data_processing/Motifs_connections/motif_pattern_connections.csv")

motifs_raw_data$Broad_categories <- NA

motifs_raw_data$Broad_categories[motifs_raw_data$motif_id %in% c(5,9,14,13,10)] <- "Core-peripherical"
motifs_raw_data$Broad_categories[motifs_raw_data$motif_id %in% c(6,16,12)] <- "Complete"
motifs_raw_data$Broad_categories[motifs_raw_data$motif_id %in% c(2,3,7,4,17,8)] <- "Fan"
motifs_raw_data$Broad_categories[motifs_raw_data$motif_id %in% c(15,11)] <- "Asymmetric complete"

motifs_raw_data$plant <- gsub("[^0-9.-]", "", motifs_raw_data$plant)
motifs_raw_data$pollinator <- gsub("[^0-9.-]", "", motifs_raw_data$pollinator)
motifs_raw_data$plant <- as.numeric(motifs_raw_data$plant)
motifs_raw_data$pollinator <- as.numeric(motifs_raw_data$pollinator)
motifs_raw_data <- motifs_raw_data %>% filter(!is.na(Broad_categories))

fan_pollinator <- motifs_raw_data$pollinator[motifs_raw_data$Broad_categories == "Fan"] %>% unique()
core_per_pollinator <- motifs_raw_data$pollinator[motifs_raw_data$Broad_categories == "Core-peripherical"] %>% unique()
complete_pollinator <- motifs_raw_data$pollinator[motifs_raw_data$Broad_categories == "Complete"] %>% unique()
asymm_pollinator <- motifs_raw_data$pollinator[motifs_raw_data$Broad_categories == "Asymmetric complete"] %>% unique()

pollinator_means_reordered$Broad_categories <- NA

pollinator_means_reordered$Broad_categories[pollinator_means_reordered$position %in% fan_pollinator] <- "Fan" 
pollinator_means_reordered$Broad_categories[pollinator_means_reordered$position %in% asymm_pollinator] <- "Medium-weak" 
pollinator_means_reordered$Broad_categories[pollinator_means_reordered$position %in% complete_pollinator] <- "Strong" 
pollinator_means_reordered$Broad_categories[pollinator_means_reordered$position %in% core_per_pollinator] <- "Weak" 


fan_plant <- motifs_raw_data$plant[motifs_raw_data$Broad_categories == "Fan"] %>% unique()
core_per_plant <- motifs_raw_data$plant[motifs_raw_data$Broad_categories == "Core-peripherical"] %>% unique()
complete_plant <- motifs_raw_data$plant[motifs_raw_data$Broad_categories == "Complete"] %>% unique()
asymm_plant <- motifs_raw_data$plant[motifs_raw_data$Broad_categories == "Asymmetric complete"] %>% unique()

plant_means$Broad_categories <- NA

plant_means$Broad_categories[plant_means$position %in% fan_plant] <- "Fan" 
plant_means$Broad_categories[plant_means$position %in% asymm_plant] <- "Medium-weak" 
plant_means$Broad_categories[plant_means$position %in% complete_plant] <- "Strong" 
plant_means$Broad_categories[plant_means$position %in% core_per_plant] <- "Weak" 



########################################
# CREATE HEATMAPS
########################################

library(ComplexHeatmap)

# PLANTS-----

# Prepare data for heatmap
heat_plants_aux <- plant_means %>% spread(Node_FG,mean) %>% select(-SE) 

heat_plants <- heat_plants_aux %>%
  group_by(position,Broad_categories) %>% 
  summarise_all(sum,na.rm = T)

heat_plants_fan <- heat_plants %>% filter(Broad_categories == "Fan") %>% select(-Broad_categories) %>% 
  as.matrix()

rownames(heat_plants_fan) <- heat_plants_fan[,1]

heat_plants_Weak <- heat_plants %>% filter(Broad_categories == "Weak") %>% select(-Broad_categories) %>% 
  as.matrix()

rownames(heat_plants_Weak) <- heat_plants_Weak[,1]

heat_plants_Strong <- heat_plants %>% filter(Broad_categories == "Strong") %>% select(-Broad_categories) %>% 
  as.matrix()

rownames(heat_plants_Strong) <- heat_plants_Strong[,1]

heat_plants_Medium_weak <- heat_plants %>% filter(Broad_categories == "Medium-weak") %>% select(-Broad_categories) %>% 
  as.matrix()

rownames(heat_plants_Medium_weak) <- heat_plants_Medium_weak[,1]


# POLLINATORS-----------     

filter_rare_groups <- T

if(filter_rare_groups == T){
  heat_pollinators_aux <- pollinator_means_reordered %>% filter(!Node_FG %in% c("Birds",
                                                                                "Lizards",
                                                                                "Other_insects")) %>% 
    spread(Node_FG,mean) %>% select(-SE,-lower)
  
  colnames(heat_pollinators_aux) <- c("position","Broad_categories","Bee",            
                                      "Coleoptera","Lepidoptera","Non-bee\nHymenoptera", 
                                      "Non-syrphids\ndiptera","Syrphids")
}else{
  heat_pollinators_aux <- pollinator_means_reordered %>% spread(Node_FG,mean) %>% select(-SE,-lower)
  
  colnames(heat_pollinators_aux) <- c("position","Broad_categories","Bee","Birds",            
                                      "Coleoptera","Lepidoptera","Lizards","Non-bee\nHymenoptera", 
                                      "Non-syrphids\ndiptera","Other insects","Syrphids")
}


heat_pollinators <- heat_pollinators_aux %>%
  group_by(position,Broad_categories) %>% 
  summarise_all(sum,na.rm = T)

heat_pollinators_fan <- heat_pollinators %>% filter(Broad_categories == "Fan") %>% select(-Broad_categories) %>% 
  as.matrix()

rownames(heat_pollinators_fan) <- heat_pollinators_fan[,1]

heat_pollinators_Weak <- heat_pollinators %>% filter(Broad_categories == "Weak") %>% select(-Broad_categories) %>% 
  as.matrix()

rownames(heat_pollinators_Weak) <- heat_pollinators_Weak[,1]

heat_pollinators_Strong <- heat_pollinators %>% filter(Broad_categories == "Strong") %>% select(-Broad_categories) %>% 
  as.matrix()

rownames(heat_pollinators_Strong) <- heat_pollinators_Strong[,1]

heat_pollinators_Medium_weak <- heat_pollinators %>% filter(Broad_categories == "Medium-weak") %>% select(-Broad_categories) %>% 
  as.matrix()

rownames(heat_pollinators_Medium_weak) <- heat_pollinators_Medium_weak[,1]



##################

#Do not know how to handle this multiplot for creating a panel 
 
# I'm going to create the 4 plots in one, 
# I'm not sure that the grouping of the functional group is correct
# when is done separately
 
#sorry for the mess of libraries that I do below 

 #Prepare first pollinators

library(tidyr)
library(data.table)
long <- melt(setDT(heat_pollinators), id.vars = c("position","Broad_categories"), variable.name = "guilds")

long_1 <- long %>% select(-Broad_categories)  

library(reshape2)
long_m <- acast(long_1, position~guilds, value.var="value")

#set manually the divisions, so far this is the best way I have seen to split the rows by categories

r_split <- c(rep(c("Fan"), 3),rep(c("Core-peripheral"), 2),"Complete",rep(c("Fan"),2),rep(c("Core-peripheral"), 4),
             rep(c("Asymmetric complete"), 2), "Complete", rep(c("Core-peripheral"), 3),rep(c("Asymmetric complete"), 2),
             "Complete", "Fan")

#set order of labels that avoids overlapping
r_split <- factor(r_split, levels=c("Core-peripheral","Complete","Fan","Asymmetric complete"))

#plat a bit with colors, a bit of a more complex set but looks nicer
library(circlize)
col_fun = colorRamp2(c(0.05644663,0.25, 0.4673256,0.75, 0.8782047), c("blue","cadetblue3", "azure2", "gold","red"))

h_pol <- Heatmap(long_m, name = "Mean\npercentile", row_split=r_split,cluster_row_slices = FALSE, 
        column_title = "Pollinator functional\ Groups",row_names_gp = gpar(fontsize = 12),col = col_fun)

 #Prepare plants

#long format
long_plants <- melt(setDT(heat_plants), id.vars = c("position","Broad_categories"), variable.name = "Functional_groups")

#filter for creating matrix
long_plants_1 <- long_plants %>% select(-Broad_categories)  


#set better colnames
long_plants_1$Functional_groups <- as.character(long_plants_1$Functional_groups)

long_plants_1$Functional_groups[long_plants_1$Functional_groups==1] <- "Cluster 1" 
long_plants_1$Functional_groups[long_plants_1$Functional_groups==2] <- "Cluster 2" 
long_plants_1$Functional_groups[long_plants_1$Functional_groups==3] <- "Cluster 3" 
long_plants_1$Functional_groups[long_plants_1$Functional_groups==4] <- "Cluster 4" 
long_plants_1$Functional_groups[long_plants_1$Functional_groups==5] <- "Cluster 5" 

long_plants_1$Functional_groups <- factor(long_plants_1$Functional_groups, levels=c("Cluster 1",
"Cluster 2" ,"Cluster 3","Cluster 4" ,"Cluster 5" ))

#create matrix with reshape
long_plants_m <- acast(long_plants_1, position~Functional_groups, value.var="value")

r_split_plants <- c(rep(c("Fan"), 3),rep(c("Core-peripheral"), 2),"Complete",rep(c("Fan"),2),rep(c("Core-peripheral"), 3),
             rep(c("Asymmetric complete"), 2), "Complete", rep(c("Core-peripheral"), 4),rep(c("Asymmetric complete"), 2),
             "Complete", "Fan")

r_split_plants <- factor(r_split, levels=c("Core-peripheral","Complete","Fan","Asymmetric complete"))


h_plan <- Heatmap(long_plants_m, name = "Mean\npercentile", row_split=r_split_plants,cluster_row_slices = FALSE, 
        column_title = "Plant functional\ Groups",row_names_gp = gpar(fontsize = 12),col = col_fun)

library(patchwork)
h_pol+h_plan


```


##REFERENCES

<div id ="refs"></div>


##SUPPLEMENTARY MATERIAL

**TABLES**

```{r, echo=FALSE, message=FALSE, cache=FALSE,  warning=FALSE}
##############################
#TABLE S1. List of studies
##############################

#Load libraries
library(kableExtra)
library(dplyr)

#Create data.frame with references

#vector with number of netw per study
`Number of networks` <- c("6", "2", "3", "1", "1", "1", "1", "2", "1", "1", "8", "16", "6", "2", "4", "1", "3", "1")

#`Network structure` <- c(rep("Web", 22), rep("Metaweb",6))

`First author` <- c("Bartomeus", "Dicks", "Dupont", "Elberling", "Fang", "Inouye", "Lundgren", "Olesen", "Small", "Souza", "Kaiser-Bunbury", "Bartomeus", 
                    "Kaiser-Bunbury", "Kaiser-Bunbury", "Peralta", "Burkle", "Arroyo-Correa", "Bundgaard")

Year <- c(2008,2002,2003,1999,2008,1988, 2005,2002,1976,2017,2017,2008,2011,2010,2006,2013,2019,2003) ###JOSE! This method is prone to error, My Beefun dataset is 2015 and not 2008. ###

#Country <- c("Spain", "England", "Denmark", "Sweden", "China", "Australia", "Greenland", "Mauritius and Azores", #"Canada", "Brasil", "Seychelles", "Spain", "Seychelles",
#"Mauritius", "Argentina", "USA", "New Zealand", "Denmark",  "Denmark", "Japan", "Canada", "Venezuela", "Japan", #"Ecuador", "New Zealand", "Venezuela",
#"USA", "Ecuador")

DOI <- c("https://doi.org/10.1007/s00442-007-0946-1", "https://doi.org/10.1046/j.0021-8790.2001.00572.x", "https://doi.org/10.1111/j.1365-2656.2008.01501.x",
         "https://doi.org/10.1111/j.1600-0587.1999.tb00507.x", "https://doi.org/10.1111/1749-4877.12190", "https://doi.org/10.1111/j.1442-9993.1988.tb00968.x",
         "https://doi.org/10.1657/1523-0430(2005)037[0514:TDAHCW]2.0.CO;2", "https://doi.org/10.1046/j.1472-4642.2002.00148.x",
         "/13960/t4km08d21", "https://doi.org/10.1111/1365-2745.12978", "https://doi.org/10.1038/nature21071", "https://github.com/ibartomeus/BeeFunData",
         "https://doi.org/10.1111/j.1365-2745.2010.01732.x", "https://doi.org/10.1016/j.ppees.2009.04.001", "https://doi.org/10.1111/ele.13510",
         "https://doi.org/10.1126/science.1232728", "https://doi.org/10.1111/1365-2745.13332", "Unpublished, Master thesis")


references <- data.frame(`First author`, Year, `Number of networks`,   DOI)

colnames(references) <- c("First author", "Year", "Number of networks",  "DOI")

#Check number of studies
#nrow(references) # 18 studies
#check number of networks
#sum(as.numeric(references$`Number of networks`)) #60

references %>%
  arrange(`First author`)%>%
  kable( longtable = T, booktabs = T,linesep = "\\addlinespace",align = c("cccc"),caption = "Table S1. List of studies ordered by author with the year of publication, number of contributed networks and digital object identifier") %>%
  kable_styling(latex_options = c("repeat_header","striped"), font_size = 12, full_width=F,position = c("center"))

```



```{r, echo=FALSE, message=FALSE, cache=FALSE, warning=FALSE, fig.height=12, fig.width=12}

library(kableExtra)

library(dplyr)
library(readxl) #read excel file (trait data)
library(dplyr) #data manipulation
library(visdat) #VISUALIZE MISSING DATA
library(naniar)
library(tidyverse)
########################################################################################################################################################
#1) READ TRAIT DATA
########################################################################################################################################################

Trait <- c("Plant height (m)", "Flower width (mm)", "Flower length (mm)", "Inflorescence width (mm)", "Style length (mm)", "Ovules per flower",
           "Flowers per plant",  "Autonomous selfing (fruit set)")

Trait1 <- c("Lifepan", "Life form", "Flower shape", "Flower symmetry", "Autonomous selfing", "Compatibility system", "Breeding system", "")

T.cat <- linebreak(c("Short-lived \n Perennial", "Herb \n Shrub \n Tree", "Brush \n Campanulate \n Capitulum \n Open \n Papilionaceous \n Tube",  "Actinomorphic \n Zygomorphic", "None \n Low \n Medium \n High", "Self-incomp. \n Partially self-comp. \n Self-comp.", "Hermaphrodite \n Monoecious \n Dioecious",""),align = c("l"))

Type <- c("Vegetative", "Floral", "Floral", "Floral", "Floral", "Floral", "Floral","Reproductive")

Type_1 <- c("Vegetative", "Vegetative", "Floral", "Floral", "Reproductive", "Reproductive", "Reproductive", "")


dat <- data.frame(Type, Trait,Type_1, Trait1)

colnames(dat) <- c("Type","Traits","Type", "Traits")

kbl(dat, booktabs = T, linesep = "\\addlinespace", escape = FALSE, align = c("c","l","c","c","l","l","c"),caption = "Table S2. Traits used to delimit the different plant functional groups divided in quantitative and categorical traits.") %>%
kable_styling(full_width = F) %>%
add_header_above(c("Quantitative traits" = 2,"Categorical traits" = 2),bold=T)  %>%
    column_spec(c(1,4), bold = T) %>% row_spec(0, bold=T)



```


**FIGURES**

```{r, echo=FALSE, message=FALSE, cache=FALSE, results='hide', warning=FALSE, fig.height=7, fig.width=13, fig.cap="Figure S1. Plant functional group composition separated in qualitative and quantitative variables. Panel A) shows the percentage of the different categories within trait represented with different colours for each functional group. Plot B) shows the radar plot of the different quantitative variables standardize on the same scale also coloured with the same patterns of colours as qualitative variables per cluster."}


#CODE TO PLOT FUNCTIONAL GROUPS
#IT CAN BE PLOT WITH MUCH LESS CODE BUT NO TIME FOR CLEANING IT


##########################################
#Visualization of plant functional groups#
##########################################

library(cowplot)
library(ggplot2)
library(tidyr)
library(dplyr)
library(reshape2)
library(data.table)
library(patchwork)

#LOAD DATA
#read unscaled trait data in order to visualize better the clusters
d <- read.csv("../Data/Csv/all_species_imputed_trait_data_forest_data.csv")

dat_1 <- read.csv("../Data/Csv/imputed_trait_data_hclust_5_clusters_forest_data.csv", row.names = "X") 

d$Clusters <- dat_1$Clusters

#select columns of interest
t <- d[c("Breeding_system","IMPUTED_Compatibility","Autonomous_selfing_level",
         "Autonomous_selfing_level_fruit_set", "Flower_morphology", "Flower_symmetry", "Flowers_per_plant", "Flowers_per_inflorescence",
         "Floral_unit_width", "Corolla_diameter_mean", "Corolla_length_mean", "STYLE_IMPUTED", "OVULES_IMPUTED", "life_form", "lifespan",
         "IMPUTED_plant_height_mean_m", "Nectar_presence_absence", "Clusters")]



##############################################################################################################################
#Prepare table qualitative variables
##############################################################################################################################

##############################################################################################################################
#Breeding system
t$Breeding_system <- factor(t$Breeding_system, levels=c("Dioecious", "Monoecious", "Hermaphrodite"))

#Summary to create table
breeding <- t %>%
  group_by(Clusters,Breeding_system) %>%
  summarise (n = n()) %>%
  mutate(Percentage = n / sum(n)*100)

breeding <- breeding[,-3]

breeding <- spread(breeding, Clusters, Percentage)

colnames(breeding)[1] <- "Category"

Trait <- data.frame(Trait= c(rep("Breeding system", 3)))

Breeding_system <- cbind(Trait, breeding)

##############################################################################################################################
#Compatibility
str(t)
t$IMPUTED_Compatibility <- as.character(t$IMPUTED_Compatibility)
t$IMPUTED_Compatibility[t$IMPUTED_Compatibility=="dioecious"] <- "Unisexual flower"
t$IMPUTED_Compatibility[t$IMPUTED_Compatibility=="monoecious"] <- "Unisexual flower"
t$IMPUTED_Compatibility[t$IMPUTED_Compatibility=="self_incompatible"] <- "Self incompatible"
t$IMPUTED_Compatibility[t$IMPUTED_Compatibility=="partially_self_compatible"] <- "Partially self compatible"
t$IMPUTED_Compatibility[t$IMPUTED_Compatibility=="self_compatible"] <- "Self compatible"

t$IMPUTED_Compatibility <- factor(t$IMPUTED_Compatibility, levels=c("Unisexual flower", "Self incompatible", "Partially self compatible", "Self compatible"))
#Summary to create table
comp <- t %>%
  group_by(Clusters,IMPUTED_Compatibility) %>%
  summarise (n = n()) %>%
  mutate(Percentage = n / sum(n)*100)

comp <- comp[,-3]

comp <- spread(comp, Clusters, Percentage)
#Replace Na's with zeros
comp[is.na(comp)] <- 0
#Set call name os categories per trait
colnames(comp)[1] <- "Category"
#Create new column
Trait <- data.frame(Trait= c(rep("Compatibility system", 4)))
#Add column
Compatibility_system <- cbind(Trait, comp)
#Bind rows
bind_rows(Breeding_system, Compatibility_system)


############################################################################################################################################
#Life form
t$life_form <- as.character(t$life_form)
t$life_form[t$life_form =="vine"] <- "Shrub"
t$life_form[t$life_form =="tree"] <- "Tree"
t$life_form[t$life_form =="herb"] <- "Herb"
t$life_form[t$life_form =="shrub"] <- "Shrub"
#Order levels
t$life_form <- factor(t$life_form, levels=c("Tree", "Shrub", "Herb"))
#Summary to create table
life_form <- t %>%
  group_by(Clusters,life_form) %>%
  summarise (n = n()) %>%
  mutate(Percentage = n / sum(n)*100)
#delete column to convert to wide
life_form <- life_form[,-3]
#convert to wide
life_form <- spread(life_form, Clusters, Percentage)
#Set call name os categories per trait
colnames(life_form)[1] <- "Category"
#Create new column
Trait <- data.frame(Trait= c(rep("Life form", 3)))
#Add column
Life_form<- cbind(Trait, life_form)
#Bind rows
bind_rows(Breeding_system, Compatibility_system, Life_form)

############################################################################################################################################
t$lifespan <- factor(t$lifespan, levels=c("Perennial","Short lived"))
#Summary to create table
life_span <- t %>%
  group_by(Clusters,lifespan) %>%
  summarise (n = n()) %>%
  mutate(Percentage = n / sum(n)*100)
#delete column to convert to wide
life_span <- life_span[,-3]
#convert to wide
life_span <- spread(life_span, Clusters, Percentage)
#Set call name os categories per trait
colnames(life_span)[1] <- "Category"
#Create new column
Trait <- data.frame(Trait= c(rep("Life span", 2)))
#Add column
Life_span<- cbind(Trait, life_span)
#Bind rows
bind_rows(Breeding_system, Compatibility_system, Life_form, Life_span)

############################################################################################################################################
t$Flower_morphology <- as.character(t$Flower_morphology)
t$Flower_morphology[t$Flower_morphology=="Funnelform"] <- "Campanulate"
t$Flower_morphology[t$Flower_morphology=="Spike"] <- "Brush"

Flower_morphology <- t %>%
  group_by(Clusters,Flower_morphology) %>%
  summarise (n = n()) %>%
  mutate(Percentage = n / sum(n)*100)
#delete column to convert to wide
Flower_morphology <- Flower_morphology[,-3]
#convert to wide
Flower_morphology <- spread(Flower_morphology, Clusters, Percentage)
#Set call name os categories per trait
colnames(Flower_morphology)[1] <- "Category"
#Create new column
Trait <- data.frame(Trait= c(rep("Flower shape", 6)))
#Add column
Flower_morphology<- cbind(Trait, Flower_morphology)
#Replace Na's with zeros
Flower_morphology[is.na(Flower_morphology)] <- 0
#Bind rows
bind_rows(Breeding_system, Compatibility_system, Life_form, Life_span,Flower_morphology)

############################################################################################################################################
t$Flower_symmetry <- as.character(t$Flower_symmetry)
t$Flower_symmetry[t$Flower_symmetry =="actinomorphic"] <- "Actinomorphic"
t$Flower_symmetry[t$Flower_symmetry =="zygomorphic"] <- "Zygomorphic"

Flower_symmetry <- t %>%
  group_by(Clusters,Flower_symmetry) %>%
  summarise (n = n()) %>%
  mutate(Percentage = n / sum(n)*100)
#delete column to convert to wide
Flower_symmetry <- Flower_symmetry[,-3]
#convert to wide
Flower_symmetry <- spread(Flower_symmetry, Clusters, Percentage)
#Set call name os categories per trait
colnames(Flower_symmetry)[1] <- "Category"
#Create new column
Trait <- data.frame(Trait= c(rep("Flower symmetry", 2)))
#Add column
Flower_symmetry<- cbind(Trait, Flower_symmetry)
#Bind rows
bind_rows(Breeding_system, Compatibility_system, Life_form, Life_span,Flower_morphology,Flower_symmetry)
############################################################################################################################################
t$Autonomous_selfing_level <- as.character(t$Autonomous_selfing_level)
t$Autonomous_selfing_level[t$Autonomous_selfing_level =="none"] <- "None"
t$Autonomous_selfing_level[t$Autonomous_selfing_level =="low"] <- "Low"
t$Autonomous_selfing_level[t$Autonomous_selfing_level =="medium"] <- "Medium"
t$Autonomous_selfing_level[t$Autonomous_selfing_level =="high"] <- "High"

#Order levels
t$Autonomous_selfing_level <- factor(t$Autonomous_selfing_level, levels=c("High", "Medium", "Low", "None"))

Selfing <- t %>%
  group_by(Clusters,Autonomous_selfing_level) %>%
  summarise (n = n()) %>%
  mutate(Percentage = n / sum(n)*100)

#delete column to convert to wide
Selfing <- Selfing[,-3]
#convert to wide
Selfing <- spread(Selfing, Clusters, Percentage)
#Set call name os categories per trait
colnames(Selfing)[1] <- "Category"
#Create new column
Trait <- data.frame(Trait= c(rep("Selfing level", 2)))
#Replace Na's with zeros
Selfing[is.na(Selfing)] <- 0
#Add column
Selfing_1 <- cbind(Trait, Selfing)
#Bind rows
bind_rows(Breeding_system, Compatibility_system, Life_form, Life_span,Flower_morphology, Selfing_1)

############################################################################################################################################
t$Nectar_presence_absence <- as.character(t$Nectar_presence_absence)
t$Nectar_presence_absence[t$Nectar_presence_absence =="yes"] <- "Yes"
t$Nectar_presence_absence[t$Nectar_presence_absence =="no"] <- "No"

Nectar <- t %>%
  group_by(Clusters,Nectar_presence_absence) %>%
  summarise (n = n()) %>%
  mutate(Percentage = n / sum(n)*100)

#delete column to convert to wide
Nectar <- Nectar[,-3]
#convert to wide
Nectar <- spread(Nectar, Clusters, Percentage)
#Set call name os categories per trait
colnames(Nectar)[1] <- "Category"
#Create new column
Trait <- data.frame(Trait= c(rep("Nectar", 2)))
#Replace Na's with zeros
Nectar[is.na(Nectar)] <- 0
#Add column
Nectar <- cbind(Trait, Nectar)
#Bind rows
bind_rows(Breeding_system, Compatibility_system, Life_form, Life_span,Flower_morphology, Flower_symmetry,Selfing_1, Nectar)


##############################################################################################################################
#Prepare table quantitative variables
##############################################################################################################################

Selfing <-  t %>% group_by(Clusters)%>% 
  select(Autonomous_selfing_level_fruit_set) %>% # select variables to summarise
  summarise_each(funs(min = min,
                     # q25 = quantile(., 0.25), 
                      median = median, 
                      #q75 = quantile(., 0.75), 
                      max = max,
                      mean = mean, 
                    sd = sd))
  

s1 <- as.data.frame(t(Selfing))
#set colnames
colnames(s1) <- c("1","2","3","4","5")
#remove the cluster row
s1 <- s1[-1,]
#convert rownames to 1st columns
s1 <- setDT(s1, keep.rownames = "TRUE")[]
colnames(s1)[1] <- "Category"
#Create data frame to add grouping variable
Trait <- data.frame(Trait= c(rep("Autonomous selfing", 5)))
#Add column
Selfing <- cbind(Trait, s1)

##############################################################################################################################
flower_number <-  t %>% group_by(Clusters)%>% 
  select(Flowers_per_plant) %>% # select variables to summarise
  summarise_each(funs(min = min,
                      # q25 = quantile(., 0.25), 
                      median = median, 
                      #q75 = quantile(., 0.75), 
                      max = max,
                      mean = mean, 
                      sd = sd))


f1 <- as.data.frame(t(flower_number))
#set colnames
colnames(f1) <- c("1","2","3","4","5")
#remove the cluster row
f1 <- f1[-1,]
#convert rownames to 1st columns
f1 <- setDT(f1, keep.rownames = "TRUE")[]
colnames(f1)[1] <- "Category"
#Create data frame to add grouping variable
Trait <- data.frame(Trait= c(rep("Flower number", 5)))
#Add column
Flower_number <- cbind(Trait, f1)


##############################################################################################################################
Flowers_per_inflorescence <-  t %>% group_by(Clusters)%>% 
  select(Flowers_per_inflorescence) %>% # select variables to summarise
  summarise_each(funs(min = min,
                      # q25 = quantile(., 0.25), 
                      median = median, 
                      #q75 = quantile(., 0.75), 
                      max = max,
                      mean = mean, 
                      sd = sd))


f_i_1 <- as.data.frame(t(Flowers_per_inflorescence))
#set colnames
colnames(f_i_1) <- c("1","2","3","4","5")
#remove the cluster row
f_i_1 <- f_i_1[-1,]
#convert rownames to 1st columns
f_i_1 <- setDT(f_i_1, keep.rownames = "TRUE")[]
colnames(f_i_1)[1] <- "Category"
#Create data frame to add grouping variable
Trait <- data.frame(Trait= c(rep("Flowers per inflorescence", 5)))
#Add column
Flower_per_inflo <- cbind(Trait, f_i_1)

bind_rows(Selfing, Flower_number, Flower_per_inflo)

##############################################################################################################################
Floral_unit_width <-  t %>% group_by(Clusters)%>% 
  select(Floral_unit_width) %>% # select variables to summarise
  summarise_each(funs(min = min,
                      # q25 = quantile(., 0.25), 
                      median = median, 
                      #q75 = quantile(., 0.75), 
                      max = max,
                      mean = mean, 
                      sd = sd))


f_u_w_1 <- as.data.frame(t(Floral_unit_width))
#set colnames
colnames(f_u_w_1) <- c("1","2","3","4","5")
#remove the cluster row
f_u_w_1 <- f_u_w_1[-1,]
#convert rownames to 1st columns
f_u_w_1 <- setDT(f_u_w_1, keep.rownames = "TRUE")[]
colnames(f_u_w_1)[1] <- "Category"
#Create data frame to add grouping variable
Trait <- data.frame(Trait= c(rep("Inflorescence width", 5)))
#Add column
Inflo_width <- cbind(Trait, f_u_w_1)

bind_rows(Selfing, Flower_number, Flower_per_inflo, Inflo_width)

##############################################################################################################################
Corolla_diameter_mean <-  t %>% group_by(Clusters)%>% 
  select(Corolla_diameter_mean) %>% # select variables to summarise
  summarise_each(funs(min = min,
                      # q25 = quantile(., 0.25), 
                      median = median, 
                      #q75 = quantile(., 0.75), 
                      max = max,
                      mean = mean, 
                      sd = sd))


c_w_1 <- as.data.frame(t(Corolla_diameter_mean))
#set colnames
colnames(c_w_1) <- c("1","2","3","4","5")
#remove the cluster row
c_w_1 <- c_w_1[-1,]
#convert rownames to 1st columns
c_w_1 <- setDT(c_w_1, keep.rownames = "TRUE")[]
colnames(c_w_1)[1] <- "Category"
#Create data frame to add grouping variable
Trait <- data.frame(Trait= c(rep("Flower width", 5)))
#Add column
Flower_width <- cbind(Trait, c_w_1)

bind_rows(Selfing, Flower_number, Flower_per_inflo, Inflo_width, Flower_width)


##############################################################################################################################
Corolla_length_mean <-  t %>% group_by(Clusters)%>% 
  select(Corolla_length_mean) %>% # select variables to summarise
  summarise_each(funs(min = min,
                      # q25 = quantile(., 0.25), 
                      median = median, 
                      #q75 = quantile(., 0.75), 
                      max = max,
                      mean = mean, 
                      sd = sd))


c_l_1 <- as.data.frame(t(Corolla_length_mean))
#set colnames
colnames(c_l_1) <- c("1","2","3","4","5")
#remove the cluster row
c_l_1 <- c_l_1[-1,]
#convert rownames to 1st columns
c_l_1 <- setDT(c_l_1, keep.rownames = "TRUE")[]
colnames(c_l_1)[1] <- "Category"
#Create data frame to add grouping variable
Trait <- data.frame(Trait= c(rep("Flower length", 5)))
#Add column
Flower_length<- cbind(Trait, c_l_1)

bind_rows(Selfing, Flower_number, Flower_per_inflo, Inflo_width, Flower_width, Flower_length)

##############################################################################################################################
STYLE_IMPUTED <-  t %>% group_by(Clusters)%>% 
  select(STYLE_IMPUTED) %>% # select variables to summarise
  summarise_each(funs(min = min,
                      # q25 = quantile(., 0.25), 
                      median = median, 
                      #q75 = quantile(., 0.75), 
                      max = max,
                      mean = mean, 
                      sd = sd))


s_l_1 <- as.data.frame(t(STYLE_IMPUTED))
#set colnames
colnames(s_l_1) <- c("1","2","3","4","5")
#remove the cluster row
s_l_1 <- s_l_1[-1,]
#convert rownames to 1st columns
s_l_1 <- setDT(s_l_1, keep.rownames = "TRUE")[]
colnames(s_l_1)[1] <- "Category"
#Create data frame to add grouping variable
Trait <- data.frame(Trait= c(rep("Style length", 5)))
#Add column
Style_length<- cbind(Trait, s_l_1)

bind_rows(Selfing, Flower_number, Flower_per_inflo, Inflo_width, Flower_width, Flower_length, Style_length)

##############################################################################################################################

OVULES_IMPUTED <-  t %>% group_by(Clusters)%>% 
  select(OVULES_IMPUTED) %>% # select variables to summarise
  summarise_each(funs(min = min,
                      # q25 = quantile(., 0.25), 
                      median = median, 
                      #q75 = quantile(., 0.75), 
                      max = max,
                      mean = mean, 
                      sd = sd))


o_n_1 <- as.data.frame(t(OVULES_IMPUTED))
#set colnames
colnames(o_n_1) <- c("1","2","3","4","5")
#remove the cluster row
o_n_1 <- o_n_1[-1,]
#convert rownames to 1st columns
o_n_1 <- setDT(o_n_1, keep.rownames = "TRUE")[]
colnames(o_n_1)[1] <- "Category"
#Create data frame to add grouping variable
Trait <- data.frame(Trait= c(rep("Ovule number", 5)))
#Add column
Ovule_number <- cbind(Trait, o_n_1)

bind_rows(Selfing, Flower_number, Flower_per_inflo, Inflo_width, Flower_width, Flower_length, Ovule_number)


##############################################################################################################################

IMPUTED_plant_height_mean_m <-  t %>% group_by(Clusters)%>% 
  select(IMPUTED_plant_height_mean_m) %>% # select variables to summarise
  summarise_each(funs(min = min,
                      # q25 = quantile(., 0.25), 
                      median = median, 
                      #q75 = quantile(., 0.75), 
                      max = max,
                      mean = mean, 
                      sd = sd))


p_h_1 <- as.data.frame(t(IMPUTED_plant_height_mean_m))
#set colnames
colnames(p_h_1) <- c("1","2","3","4","5")
#remove the cluster row
p_h_1 <- p_h_1[-1,]
#convert rownames to 1st columns
p_h_1 <- setDT(p_h_1, keep.rownames = "TRUE")[]
colnames(p_h_1)[1] <- "Category"
#Create data frame to add grouping variable
Trait <- data.frame(Trait= c(rep("Plant height", 5)))
#Add column
Plant_height <- cbind(Trait, p_h_1)


#Bind quantitative and qualitative variables
Table_all_traits <- bind_rows(Breeding_system, Compatibility_system, Life_form, Life_span,Flower_morphology, Flower_symmetry,Selfing_1, Nectar,
          Selfing, Flower_number, Flower_per_inflo, Inflo_width, Flower_width, Flower_length, Style_length, Ovule_number, Plant_height)

#Select just two decimals
is.num <- sapply(Table_all_traits, is.numeric)
Table_all_traits[is.num] <- lapply(Table_all_traits[is.num], round, 2)

colnames(Table_all_traits) <- c("Trait", "Category", "Cluster 1", "Cluster 2", "Cluster 3", "Cluster 4", "Cluster 5") 




#LOAD LIBRARIES
#devtools::install_github("ricardo-bion/ggradar", dependencies=TRUE)
suppressPackageStartupMessages(library(dplyr))
library(scales)
library(tibble)
library(ggradar)
library(janitor)
library(grid)
library(dplyr)
library(lubridate)
#QUANTITATIVVE VARIABLES

#generate subset of quantitative variables for plotting
quant_median <- subset(Table_all_traits, Category=="median")

#delete col number 2
quant_median <- quant_median[,-2]

#transpose dataframe
final_df <- as.data.frame(t(quant_median))

#rownames to colnames (1st one)
final_df_1 <- final_df %>% row_to_names(row_number = 1)

#Convert all variables to numeric
final_df_2 <- sapply(final_df_1, function(x) as.numeric(as.character(x)))

#set back the missed rownames in the processing
rownames(final_df_2) <- rownames(final_df_1)

# Convert to dataframe
final_df_2 <- as.data.frame(final_df_2)

# Scale values and set rowname as column
final_df_3 <-final_df_2 %>% rownames_to_column( var = "group" ) %>%   mutate_at(vars(-group),funs(rescale)) 

#Plot Radar
#ggradar(final_df_3) 


#QUALITATIVE VARIABLES

#LOAD DATA
#read unscaled trait data in order to visualize better the clusters
d <- read.csv("../Data/Csv/all_species_imputed_trait_data_forest_data.csv")

dat_1 <- read.csv("../Data/Csv/imputed_trait_data_hclust_5_clusters_forest_data.csv", row.names = "X") 

d$Clusters <- dat_1$Clusters

#select columns of interest
t <- d[c("Breeding_system","IMPUTED_Compatibility","Autonomous_selfing_level",
         "Autonomous_selfing_level_fruit_set", "Flower_morphology", "Flower_symmetry", "Flowers_per_plant", "Flowers_per_inflorescence",
         "Floral_unit_width", "Corolla_diameter_mean", "Corolla_length_mean", "STYLE_IMPUTED", "OVULES_IMPUTED", "life_form", "lifespan",
         "IMPUTED_plant_height_mean_m", "Nectar_presence_absence", "Clusters")]



##############################################################################################################################
#Prepare table qualitative variables
##############################################################################################################################

##############################################################################################################################
#Breeding system
t$Breeding_system <- factor(t$Breeding_system, levels=c("Dioecious", "Monoecious", "Hermaphrodite"))

#Summary to create table
breeding <- t %>%
  group_by(Clusters,Breeding_system) %>%
  summarise (n = n()) %>%
  mutate(Percentage = n / sum(n)*100)

breeding <- breeding[,-3]

breeding <- spread(breeding, Clusters, Percentage)

colnames(breeding)[1] <- "Category"

Trait <- data.frame(Trait= c(rep("Breeding system", 3)))

Breeding_system <- cbind(Trait, breeding)

##############################################################################################################################
#Compatibility
str(t)
t$IMPUTED_Compatibility <- as.character(t$IMPUTED_Compatibility)
t$IMPUTED_Compatibility[t$IMPUTED_Compatibility=="dioecious"] <- "Self incompatible"
t$IMPUTED_Compatibility[t$IMPUTED_Compatibility=="monoecious"] <- "Self incompatible"
t$IMPUTED_Compatibility[t$IMPUTED_Compatibility=="self_incompatible"] <- "Self incompatible"
t$IMPUTED_Compatibility[t$IMPUTED_Compatibility=="partially_self_compatible"] <- "Partially self compatible"
t$IMPUTED_Compatibility[t$IMPUTED_Compatibility=="self_compatible"] <- "Self compatible"

t$IMPUTED_Compatibility <- factor(t$IMPUTED_Compatibility, levels=c("Self incompatible", "Partially self compatible", "Self compatible"))
#Summary to create table
comp <- t %>%
  group_by(Clusters,IMPUTED_Compatibility) %>%
  summarise (n = n()) %>%
  mutate(Percentage = n / sum(n)*100)

comp <- comp[,-3]

comp <- spread(comp, Clusters, Percentage)
#Replace Na's with zeros
comp[is.na(comp)] <- 0
#Set call name os categories per trait
colnames(comp)[1] <- "Category"
#Create new column
Trait <- data.frame(Trait= c(rep("Compatibility system", 3)))
#Add column
Compatibility_system <- cbind(Trait, comp)
#Bind rows
bind_rows(Breeding_system, Compatibility_system)


############################################################################################################################################
#Life form
t$life_form <- as.character(t$life_form)
t$life_form[t$life_form =="vine"] <- "Shrub"
t$life_form[t$life_form =="tree"] <- "Tree"
t$life_form[t$life_form =="herb"] <- "Herb"
t$life_form[t$life_form =="shrub"] <- "Shrub"
#Order levels
t$life_form <- factor(t$life_form, levels=c("Tree", "Shrub", "Herb"))
#Summary to create table
life_form <- t %>%
  group_by(Clusters,life_form) %>%
  summarise (n = n()) %>%
  mutate(Percentage = n / sum(n)*100)
#delete column to convert to wide
life_form <- life_form[,-3]
#convert to wide
life_form <- spread(life_form, Clusters, Percentage)
#Set call name os categories per trait
colnames(life_form)[1] <- "Category"
#Create new column
Trait <- data.frame(Trait= c(rep("Life form", 3)))
#Add column
Life_form<- cbind(Trait, life_form)
#Bind rows
bind_rows(Breeding_system, Compatibility_system, Life_form)

############################################################################################################################################
t$lifespan <- factor(t$lifespan, levels=c("Perennial","Short lived"))
#Summary to create table
life_span <- t %>%
  group_by(Clusters,lifespan) %>%
  summarise (n = n()) %>%
  mutate(Percentage = n / sum(n)*100)
#delete column to convert to wide
life_span <- life_span[,-3]
#convert to wide
life_span <- spread(life_span, Clusters, Percentage)
#Set call name os categories per trait
colnames(life_span)[1] <- "Category"
#Create new column
Trait <- data.frame(Trait= c(rep("Life span", 2)))
#Add column
Life_span<- cbind(Trait, life_span)
#Bind rows
bind_rows(Breeding_system, Compatibility_system, Life_form, Life_span)

############################################################################################################################################
#t$Flower_morphology <- as.character(t$Flower_morphology)
#t$Flower_morphology[t$Flower_morphology=="Funnelform"] <- "Campanulate"
#t$Flower_morphology[t$Flower_morphology=="Spike"] <- "Brush"
#
#Flower_morphology <- t %>%
#  group_by(Clusters,Flower_morphology) %>%
#  summarise (n = n()) %>%
#  mutate(Percentage = n / sum(n)*100)
##delete column to convert to wide
#Flower_morphology <- Flower_morphology[,-3]
##convert to wide
#Flower_morphology <- spread(Flower_morphology, Clusters, Percentage)
##Set call name os categories per trait
#colnames(Flower_morphology)[1] <- "Category"
##Create new column
#Trait <- data.frame(Trait= c(rep("Flower shape", 6)))
##Add column
#Flower_morphology<- cbind(Trait, Flower_morphology)
##Replace Na's with zeros
#Flower_morphology[is.na(Flower_morphology)] <- 0
##Bind rows
#bind_rows(Breeding_system, Compatibility_system, Life_form, Life_span,Flower_morphology)
#
############################################################################################################################################
t$Flower_symmetry <- as.character(t$Flower_symmetry)
t$Flower_symmetry[t$Flower_symmetry =="actinomorphic"] <- "Actinomorphic"
t$Flower_symmetry[t$Flower_symmetry =="zygomorphic"] <- "Zygomorphic"

Flower_symmetry <- t %>%
  group_by(Clusters,Flower_symmetry) %>%
  summarise (n = n()) %>%
  mutate(Percentage = n / sum(n)*100)
#delete column to convert to wide
Flower_symmetry <- Flower_symmetry[,-3]
#convert to wide
Flower_symmetry <- spread(Flower_symmetry, Clusters, Percentage)
#Set call name os categories per trait
colnames(Flower_symmetry)[1] <- "Category"
#Create new column
Trait <- data.frame(Trait= c(rep("Flower symmetry", 2)))
#Add column
Flower_symmetry<- cbind(Trait, Flower_symmetry)
#Bind rows
bind_rows(Breeding_system, Compatibility_system, Life_form, Life_span,Flower_morphology,Flower_symmetry)
############################################################################################################################################
#t$Autonomous_selfing_level <- as.character(t$Autonomous_selfing_level)
#t$Autonomous_selfing_level[t$Autonomous_selfing_level =="none"] <- "None"
#t$Autonomous_selfing_level[t$Autonomous_selfing_level =="low"] <- "Low"
#t$Autonomous_selfing_level[t$Autonomous_selfing_level =="medium"] <- "Medium"
#t$Autonomous_selfing_level[t$Autonomous_selfing_level =="high"] <- "High"
#
##Order levels
#t$Autonomous_selfing_level <- factor(t$Autonomous_selfing_level, levels=c("High", "Medium", "Low", "None"))
#
#Selfing <- t %>%
#  group_by(Clusters,Autonomous_selfing_level) %>%
#  summarise (n = n()) %>%
#  mutate(Percentage = n / sum(n)*100)
#
##delete column to convert to wide
#Selfing <- Selfing[,-3]
##convert to wide
#Selfing <- spread(Selfing, Clusters, Percentage)
##Set call name os categories per trait
#colnames(Selfing)[1] <- "Category"
##Create new column
#Trait <- data.frame(Trait= c(rep("Selfing level", 2)))
##Replace Na's with zeros
#Selfing[is.na(Selfing)] <- 0
##Add column
#Selfing_1 <- cbind(Trait, Selfing)
##Bind rows
#bind_rows(Breeding_system, Compatibility_system, Life_form, Life_span,Flower_morphology, Selfing_1)
#
#############################################################################################################################################
t$Nectar_presence_absence <- as.character(t$Nectar_presence_absence)
t$Nectar_presence_absence[t$Nectar_presence_absence =="yes"] <- "Yes"
t$Nectar_presence_absence[t$Nectar_presence_absence =="no"] <- "No"

Nectar <- t %>%
  group_by(Clusters,Nectar_presence_absence) %>%
  summarise (n = n()) %>%
  mutate(Percentage = n / sum(n)*100)

#delete column to convert to wide
Nectar <- Nectar[,-3]
#convert to wide
Nectar <- spread(Nectar, Clusters, Percentage)
#Set call name os categories per trait
colnames(Nectar)[1] <- "Category"
#Create new column
Trait <- data.frame(Trait= c(rep("Nectar", 2)))
#Replace Na's with zeros
Nectar[is.na(Nectar)] <- 0
#Add column
Nectar <- cbind(Trait, Nectar)
#Bind rows
data <- bind_rows(Breeding_system, Compatibility_system, Life_form, Life_span, Flower_symmetry, Nectar)

#remove first col
data_1 <- data[,-1]
colnames(data_1) <- c("Category", "Cluster 1", "Cluster 2", "Cluster 3", "Cluster 4", "Cluster 5")

#transpose dataframe
data_2 <- as.data.frame(t(data_1))

#rownames to colnames (1st one)
data_3 <- data_2 %>% row_to_names(row_number = 1)

#Convert all variables to numeric
data_4 <- sapply(data_3, function(x) as.numeric(as.character(x)))

#set back the missed rownames in the processing
rownames(data_4) <- rownames(data_3)

# Convert to dataframe
data_4 <- as.data.frame(data_4)

# Scale values and set rowname as column
data_5 <-data_4 %>% rownames_to_column( var = "group" )


data_6 <- melt(data_5)

cluster1 <- subset(data_6, group=="Cluster 1")

cluster1$traits <- c(rep("Breeding system",3), rep("Compatibility",3), rep("Life form",3),
                     rep("Life span",2), rep("Flower symmetry",2), rep("Nectar",2))


#Try to achieve the desire output with plot_grid

c1 <- cluster1 %>% 
  ggplot(aes(x = variable,  y = value, fill = group))  +  
  geom_col(position = "dodge") +   scale_fill_manual(name = NULL,values=c("sandybrown"))+
  facet_grid(~traits, scales = "free_x", space = "free_x")+theme_bw()+
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank())+scale_y_continuous(expand = c(0,0)) +
  theme(axis.title.x = element_blank(), axis.text.x=element_blank(),plot.title = element_text(size = 18))+ ylab("")+
  ggtitle("A) Qualitative variables")


cluster2 <- subset(data_6, group=="Cluster 2")

cluster2$traits <- c(rep("Breeding system",3), rep("Compatibility",3), rep("Life form",3),
                     rep("Life span",2), rep("Flower symmetry",2), rep("Nectar",2))

c2 <- cluster2 %>% 
  ggplot(aes(x = variable,  y = value, fill = group))  +  
  geom_col(position = "dodge") +   scale_fill_manual(name = NULL,values=c("#7BB0A3"))+
  facet_grid(~traits, scales = "free_x", space = "free_x")+theme_bw()+
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank())+scale_y_continuous(expand = c(0,0)) +
  theme(strip.background = element_blank(), strip.text = element_blank())+
  theme(axis.title.x = element_blank(), axis.text.x=element_blank())+ylab("")



cluster3 <- subset(data_6, group=="Cluster 3")

cluster3$traits <- c(rep("Breeding system",3), rep("Compatibility",3), rep("Life form",3),
                     rep("Life span",2), rep("Flower symmetry",2), rep("Nectar",2))



c3 <- cluster3 %>% 
  ggplot(aes(x = variable,  y = value, fill = group))  +  
  geom_col(position = "dodge") +   scale_fill_manual(name = NULL,values=c("lightsteelblue2"))+
  facet_grid(~traits, scales = "free_x", space = "free_x")+theme_bw()+
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank())+scale_y_continuous(expand = c(0,0)) +
  theme(axis.title.x = element_blank(), axis.text.x=element_blank())+
  theme(strip.background = element_blank(), strip.text = element_blank())+ylab("Percentage")


cluster4 <- subset(data_6, group=="Cluster 4")

cluster4$traits <- c(rep("Breeding system",3), rep("Compatibility",3), rep("Life form",3),
                     rep("Life span",2), rep("Flower symmetry",2), rep("Nectar",2))

c4 <- cluster4 %>% 
  ggplot(aes(x = variable,  y = value, fill = group))  +  
  geom_col(position = "dodge") +   scale_fill_manual(name = NULL,values=c("thistle"))+
  facet_grid(~traits, scales = "free_x", space = "free_x")+theme_bw()+
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank())+scale_y_continuous(expand = c(0,0)) +
  theme(axis.title.x = element_blank(), axis.text.x=element_blank())+
  theme(strip.background = element_blank(), strip.text = element_blank())+ylab("")




cluster5 <- subset(data_6, group=="Cluster 5")

cluster5$traits <- c(rep("Breeding system",3), rep("Compatibility",3), rep("Life form",3),
                     rep("Life span",2), rep("Flower symmetry",2), rep("Nectar",2))
c5 <- cluster5 %>% 
  ggplot(aes(x = variable,  y = value, fill = group))  +  
  geom_col(position = "dodge") +   scale_fill_manual(name = NULL,values=c("lightgoldenrod2"))+
  facet_grid(~traits, scales = "free_x", space = "free_x")+theme_bw()+
  scale_y_continuous(expand = c(0,0)) +
  theme(axis.text.x = element_text(angle = 45,vjust = 1, hjust=1))+
  theme(strip.background = element_blank(), strip.text = element_blank())+ylab("")+xlab("")

A <- c1 + c2 + c3 + c4 + c5 + plot_layout(ncol = 1)
B <- ggradar(final_df_3, group.colours=c("sandybrown", "#7BB0A3","lightsteelblue2", "thistle", "lightgoldenrod2"),
             legend.text.size=5, grid.label.size = 0,legend.position = "none",axis.label.size=3)+ 
  guides(shape = guide_legend(override.aes = list(size = 0.75)))+ ggtitle("B) Quantitative variables")+
  theme(plot.title = element_text(size = 18))

patch <- A | B 

patch + plot_annotation(title = "Plant functional group composition",theme = theme(plot.title = element_text(size = 20,face="bold")))

```



```{r, echo=FALSE, message=FALSE, cache=FALSE, results='hide', warning=FALSE, fig.height=7, fig.width=13, fig.cap="Figure S2. Hierarchical clustering dendrogram with the branches coloured by the optimal number of clusters (5). The labels of the subgroup of species (N = 524) used in this study are coloured in black in order to show the evenness of the distribution of the species across clusters. The rest of species labels are omitted for visualization purposes (N = 982)."}

library(ggplot2)
library(dendextend)
library(dplyr)

e.clust_5 <- readRDS("../Data/RData/e.clust_5.rds")

dendro <- as.dendrogram(e.clust_5)
dendro.col <- dendro %>%
  set("branches_k_color", k = 5, value =   c("lightsteelblue2", "thistle", "sandybrown", "#7BB0A3", "lightgoldenrod2")) %>%
  set("branches_lwd", 0.7) %>%
  set("labels_colors", 
      value = c("darkslategray")) %>% 
  set("labels_cex", 0.075) 


labels_colors(dendro.col) <- get_leaves_branches_col(dendro.col)

# We use "darkgrey" to color some species
final_d_1 <- read.csv("../Data/Csv/data_for_motifs_analysis_1.csv")

plant_species <- unique(final_d_1$Plant_species)

index_species_out <- which(names(labels_colors(dendro.col)) %in% plant_species)

'%ni%' <- Negate('%in%')

index_species_in <- which(names(labels_colors(dendro.col)) %ni% plant_species)

labels_colors(dendro.col)[index_species_out] <- "black"
labels_colors(dendro.col)[index_species_in] <- "white"


ggd1 <- as.ggdend(dendro.col)

ggd1$labels$angle <- 90
ggd1$labels$vjust <- 1
ggd1$labels$hjust <- 1



ggplot(ggd1,offset_labels=-0.05) + theme(panel.grid.major = element_blank(),
 axis.text = element_blank(),axis.title = element_blank()) +
  ggtitle("Plant functional groups")+
  theme(plot.title = element_text(hjust = 0.5, vjust = -2,size = 20,face="bold"))+
  annotate("text", x=140, y=1.65, label= "Perennials self-incompatible large flowers ", size=2.5)+
  annotate("text", x=380, y=2.15, label= "Tall plants small unisexual flowers", size=2.5) +
  annotate("text", x=600, y=3.85, label= "Short-lived selfers", size=2.5) +
  annotate("text", x=1400, y=2.05, label= "Short-lived non-selfers \n long zygomorphic flowers", size=2.5) +annotate("text", x=950, y=2.05, label= "Small non-selfers perennials", size=2.5) 



```


```{r, echo=FALSE, message=FALSE, cache=FALSE,  warning=FALSE, fig.cap="Figure S3. Comparison of the motif frequencies between empirical and simulated networks. Average percentages of motifs close to 0 and 100 indicate under- and over- representation in empirical networks, after removing non-robust links, that is, interactions whose frequency was equal to one. The different motifs are coloured by the mean path length as done in @simmons2020.", fig.width=9,fig.height=5}
library(lme4)
library(nlme)
library(tidyverse)
source("../Scripts/Scripts_Alfonso/add_study_id.R")
d <- read_csv("../Data/Csv/Motifs_frequencies_and_null_models_NOSING/Motifs_frequency_percentile_NOSING.csv")
d <- add_study_id(d)
#str(d)
#head(d)

#ggplot(d %>% filter(motif != 1), aes(percentil_sizeclass))+
#  geom_histogram(color="black", fill="white")+
#  facet_wrap(~motif)+
#  theme_bw()+
#  labs(x="Sizeclass percentile")
#
# Motifs tend to be over- and under-represensented in real networks

# Mean percentile and SE taking into account the study system
motif_codes <- d %>% filter(motif != 1) %>% # We remove links (motif code: 1)
  select(motif) %>% unique() %>% pull()
motif_means <- tibble(motif = motif_codes)
motif_means$mean <- NA
motif_means$SE <- NA

for(i.motif in 1:length(motif_codes)){
  
  m <- lmer(percentil_sizeclass ~ 1+(1|study_id), #HERE WE NEED STUDY SYSTEM ONLY!! 
            data = subset(d, motif == motif_codes[i.motif]))  
  
  motif_means$mean[i.motif] <- fixed.effects(m) %>% unname()
  motif_means$SE[i.motif] <- sqrt(diag(vcov(m)))
  
}

#Add categories based on path length set by Simmons 2021 et al., Functional Ecology
d$Broad_categories[d$motif==2 | d$motif==7 | d$motif==17 | d$motif==3|d$motif==4|d$motif==8] <- "Fan" 

d$Broad_categories[d$motif==15 | d$motif==11] <- "Medium-weak" 

d$Broad_categories[d$motif==6 | d$motif==16 |  d$motif==12] <- "Strong" 

d$Broad_categories[d$motif==5 | d$motif==9 |  d$motif==14|  d$motif==13|  d$motif==10] <- "Weak" 

#order the categories from short to long path length
d$Broad_categories <- factor(d$Broad_categories, levels = c("Strong", "Fan", "Medium-weak", "Weak"))

ggplot(NULL) + 
  geom_point(data = d %>% filter(motif != 1),
             aes(y=as.factor(motif), x=100*percentil_sizeclass, 
                 color = as.factor(Broad_categories)),
             position = "jitter",alpha=0.5)+
  geom_errorbar(data = motif_means,aes(y = as.factor(motif), xmin=100*(mean-SE), xmax=100*(mean+SE)), 
                width=1.0,size=1)+
  geom_point(data = motif_means,aes(y = as.factor(motif), x=100*mean), 
                size=2)+
  labs(y="Motif", x = "Percentile (%)",colour="Path length classification")+
  theme_bw() + scale_color_manual(labels = c('Strong' = expression(paste("Complete (", bar(x), " = 1.38)")),'Fan' = expression(paste("Fan (", bar(x), " = 1.48)")), 'Medium-weak' = expression(paste("Asymmetric complete (", bar(x), " = 1.60)")), "Weak" =expression(paste("Core-peripheral (", bar(x), " = 1.85)"))), name = "Path length classification",values = c("grey25","springgreen4","sienna2","goldenrod2"),guide = guide_legend(title.position = "top",nrow = 2)) +
theme(legend.text.align = 0)+
  theme(legend.position="bottom")

#Trying to maintain a gradient from low to high in colors

#Fig 1 Should be a dot plot (or forest plot) of the mean +- SE of the 15 motifs.
#NICE! Can we put motifs in Y axes, and % in X?
```


```{r, echo=FALSE, message=FALSE, cache=FALSE,  warning=FALSE, fig.height=8,fig.width=8,fig.align = 'center', fig.cap="Figure S4. Heatmap indicating under- and over- representation of pollinator and plant functional groups in the different motif positions, after removing non-robust links, that is, interactions whose frequency was equal to one. The different motif positions are dividied by the average path length clasification by @simmons2020."}

library(lme4)
library(nlme)
library(tidyverse)
library(stringi)
source("../Scripts/Scripts_Alfonso/add_study_id.R")

#############################################
# EXTRACT MEAN VALUES
#############################################


all_position_percentiles <- read_csv("../Data/Csv/Motifs_positions_and_null_models_NOSING/GF_positions_frequency_percentile_NOSING.csv")

all_position_percentiles$position <- stri_extract_first_regex(all_position_percentiles$position,
                                                              "[0-9]+") %>% as.numeric()

all_position_percentiles <- add_study_id(all_position_percentiles)
#str(all_position_percentiles)
#head(all_position_percentiles)

list_plants_FG <- as.character(1:10)

plant_position_percentiles_filtered <- all_position_percentiles %>% 
  filter(Node_FG %in% list_plants_FG, !position %in% c(1,2),
         !is.na(expected_freq_its_GF)) #ME DA ERROR
pollinator_position_percentiles_filtered <- all_position_percentiles %>% 
  filter(!Node_FG %in% list_plants_FG, !position %in% c(1,2),
         !is.na(expected_freq_its_GF))


# Plants-------------

# Mean percentile and SE taking into account the study system
plant_codes <- plant_position_percentiles_filtered$position %>% unique()
plant_means <- plant_position_percentiles_filtered %>% select(position,Node_FG) %>% unique()
plant_means$mean <- NA
plant_means$SE <- NA


for(i.pos in 1:length(plant_codes)){
  
  m <- lmer(percentil_its_GF ~ Node_FG + (1|study_id),
            data = plant_position_percentiles_filtered %>%
              filter(position == plant_codes[i.pos]))  
  
  temp <- fixed.effects(m) %>% unname()
  plant_means$mean[plant_means$position == plant_codes[i.pos]] <- c(temp[1],
                                                                    temp[1]+temp[2],
                                                                    temp[1]+temp[3],
                                                                    temp[1]+temp[4],
                                                                    temp[1]+temp[5]) ## to get real means per FG
  temp <- sqrt(diag(vcov(m)))
  plant_means$SE[plant_means$position == plant_codes[i.pos]] <- c(temp[1], 
                                                                  temp[1]+temp[2],
                                                                  temp[1]+temp[3],
                                                                  temp[1]+temp[4],
                                                                  temp[1]+temp[5])
  
}


# Pollinators--------

# Mean percentile and SE taking into account the study system
pollinator_codes <- pollinator_position_percentiles_filtered$position %>% unique()
pollinator_means <- pollinator_position_percentiles_filtered %>% select(position,Node_FG) %>% unique()
pollinator_means$mean <- NA
pollinator_means$SE <- NA
pollinator_means_reordered <- NULL

for(i.pos in 1:length(pollinator_codes)){
  
  m <- lmer(percentil_its_GF ~ Node_FG + (1|study_id), #HERE WE NEED STUDY SYSTEM ONLY!! 
            data = pollinator_position_percentiles_filtered %>%
              filter(position == pollinator_codes[i.pos]),
            control = lmerControl(optimizer ="Nelder_Mead")) # I changed the optimizer because motif 8 (i.pos = 3) caused convergence problems, max gradient = 0.0022 > 0.002.
  
  temp <- fixed.effects(m) %>% unname()
  pollinator_means_aux <- pollinator_means[pollinator_means$position == pollinator_codes[i.pos],] %>% arrange(Node_FG)
  
  pollinator_means_aux$mean <- c(temp[1],
                                 temp[1]+temp[2],
                                 temp[1]+temp[3],
                                 temp[1]+temp[4],
                                 temp[1]+temp[5],
                                 temp[1]+temp[6],
                                 temp[1]+temp[7],
                                 temp[1]+temp[8],
                                 temp[1]+temp[9]) ## to get real means per FG
  
  
  temp <- sqrt(diag(vcov(m)))
  pollinator_means_aux$SE <- c(temp[1],
                               temp[1]+temp[2],
                               temp[1]+temp[3],
                               temp[1]+temp[4],
                               temp[1]+temp[5],
                               temp[1]+temp[6],
                               temp[1]+temp[7],
                               temp[1]+temp[8],
                               temp[1]+temp[9])
  
  pollinator_means_reordered <- bind_rows(pollinator_means_reordered,pollinator_means_aux)
  
}

# There are lower limits (mean - SE) smaller than 0 (see Other insects)
# We set the lower limit of those error bars to zero

pollinator_means_reordered <- pollinator_means_reordered %>% mutate(lower = mean-SE)
pollinator_means_reordered$lower[pollinator_means_reordered$lower < 0] <- 0

#############################################
# ADDING BROAD MOTIF CATEGORIES TO POSITIONS
#############################################

motifs_raw_data <- read_csv("../Data/Data_processing/Motifs_connections/motif_pattern_connections.csv")

motifs_raw_data$Broad_categories <- NA

motifs_raw_data$Broad_categories[motifs_raw_data$motif_id %in% c(5,9,14,13,10)] <- "Core-peripherical"
motifs_raw_data$Broad_categories[motifs_raw_data$motif_id %in% c(6,16,12)] <- "Complete"
motifs_raw_data$Broad_categories[motifs_raw_data$motif_id %in% c(2,3,7,4,17,8)] <- "Fan"
motifs_raw_data$Broad_categories[motifs_raw_data$motif_id %in% c(15,11)] <- "Asymmetric complete"

motifs_raw_data$plant <- gsub("[^0-9.-]", "", motifs_raw_data$plant)
motifs_raw_data$pollinator <- gsub("[^0-9.-]", "", motifs_raw_data$pollinator)
motifs_raw_data$plant <- as.numeric(motifs_raw_data$plant)
motifs_raw_data$pollinator <- as.numeric(motifs_raw_data$pollinator)
motifs_raw_data <- motifs_raw_data %>% filter(!is.na(Broad_categories))

fan_pollinator <- motifs_raw_data$pollinator[motifs_raw_data$Broad_categories == "Fan"] %>% unique()
core_per_pollinator <- motifs_raw_data$pollinator[motifs_raw_data$Broad_categories == "Core-peripherical"] %>% unique()
complete_pollinator <- motifs_raw_data$pollinator[motifs_raw_data$Broad_categories == "Complete"] %>% unique()
asymm_pollinator <- motifs_raw_data$pollinator[motifs_raw_data$Broad_categories == "Asymmetric complete"] %>% unique()

pollinator_means_reordered$Broad_categories <- NA

pollinator_means_reordered$Broad_categories[pollinator_means_reordered$position %in% fan_pollinator] <- "Fan" 
pollinator_means_reordered$Broad_categories[pollinator_means_reordered$position %in% asymm_pollinator] <- "Medium-weak" 
pollinator_means_reordered$Broad_categories[pollinator_means_reordered$position %in% complete_pollinator] <- "Strong" 
pollinator_means_reordered$Broad_categories[pollinator_means_reordered$position %in% core_per_pollinator] <- "Weak" 


fan_plant <- motifs_raw_data$plant[motifs_raw_data$Broad_categories == "Fan"] %>% unique()
core_per_plant <- motifs_raw_data$plant[motifs_raw_data$Broad_categories == "Core-peripherical"] %>% unique()
complete_plant <- motifs_raw_data$plant[motifs_raw_data$Broad_categories == "Complete"] %>% unique()
asymm_plant <- motifs_raw_data$plant[motifs_raw_data$Broad_categories == "Asymmetric complete"] %>% unique()

plant_means$Broad_categories <- NA

plant_means$Broad_categories[plant_means$position %in% fan_plant] <- "Fan" 
plant_means$Broad_categories[plant_means$position %in% asymm_plant] <- "Medium-weak" 
plant_means$Broad_categories[plant_means$position %in% complete_plant] <- "Strong" 
plant_means$Broad_categories[plant_means$position %in% core_per_plant] <- "Weak" 



########################################
# CREATE HEATMAPS
########################################

library(ComplexHeatmap)

# PLANTS-----

# Prepare data for heatmap
heat_plants_aux <- plant_means %>% spread(Node_FG,mean) %>% select(-SE) 

heat_plants <- heat_plants_aux %>%
  group_by(position,Broad_categories) %>% 
  summarise_all(sum,na.rm = T)

heat_plants_fan <- heat_plants %>% filter(Broad_categories == "Fan") %>% select(-Broad_categories) %>% 
  as.matrix()

rownames(heat_plants_fan) <- heat_plants_fan[,1]

heat_plants_Weak <- heat_plants %>% filter(Broad_categories == "Weak") %>% select(-Broad_categories) %>% 
  as.matrix()

rownames(heat_plants_Weak) <- heat_plants_Weak[,1]

heat_plants_Strong <- heat_plants %>% filter(Broad_categories == "Strong") %>% select(-Broad_categories) %>% 
  as.matrix()

rownames(heat_plants_Strong) <- heat_plants_Strong[,1]

heat_plants_Medium_weak <- heat_plants %>% filter(Broad_categories == "Medium-weak") %>% select(-Broad_categories) %>% 
  as.matrix()

rownames(heat_plants_Medium_weak) <- heat_plants_Medium_weak[,1]


# POLLINATORS-----------     

filter_rare_groups <- T

if(filter_rare_groups == T){
  heat_pollinators_aux <- pollinator_means_reordered %>% filter(!Node_FG %in% c("Birds",
                                                                                "Lizards",
                                                                                "Other_insects")) %>% 
    spread(Node_FG,mean) %>% select(-SE,-lower)
  
  colnames(heat_pollinators_aux) <- c("position","Broad_categories","Bee",            
                                      "Coleoptera","Lepidoptera","Non-bee\nHymenoptera", 
                                      "Non-syrphids\ndiptera","Syrphids")
}else{
  heat_pollinators_aux <- pollinator_means_reordered %>% spread(Node_FG,mean) %>% select(-SE,-lower)
  
  colnames(heat_pollinators_aux) <- c("position","Broad_categories","Bee","Birds",            
                                      "Coleoptera","Lepidoptera","Lizards","Non-bee\nHymenoptera", 
                                      "Non-syrphids\ndiptera","Other insects","Syrphids")
}


heat_pollinators <- heat_pollinators_aux %>%
  group_by(position,Broad_categories) %>% 
  summarise_all(sum,na.rm = T)

heat_pollinators_fan <- heat_pollinators %>% filter(Broad_categories == "Fan") %>% select(-Broad_categories) %>% 
  as.matrix()

rownames(heat_pollinators_fan) <- heat_pollinators_fan[,1]

heat_pollinators_Weak <- heat_pollinators %>% filter(Broad_categories == "Weak") %>% select(-Broad_categories) %>% 
  as.matrix()

rownames(heat_pollinators_Weak) <- heat_pollinators_Weak[,1]

heat_pollinators_Strong <- heat_pollinators %>% filter(Broad_categories == "Strong") %>% select(-Broad_categories) %>% 
  as.matrix()

rownames(heat_pollinators_Strong) <- heat_pollinators_Strong[,1]

heat_pollinators_Medium_weak <- heat_pollinators %>% filter(Broad_categories == "Medium-weak") %>% select(-Broad_categories) %>% 
  as.matrix()

rownames(heat_pollinators_Medium_weak) <- heat_pollinators_Medium_weak[,1]



##################

#Do not know how to handle this multiplot for creating a panel 
 
# I'm going to create the 4 plots in one, 
# I'm not sure that the grouping of the functional group is correct
# when is done separately
 
#sorry for the mess of libraries that I do below 

 #Prepare first pollinators

library(tidyr)
library(data.table)
long <- melt(setDT(heat_pollinators), id.vars = c("position","Broad_categories"), variable.name = "guilds")

long_1 <- long %>% select(-Broad_categories)  

library(reshape2)
long_m <- acast(long_1, position~guilds, value.var="value")

#set manually the divisions, so far this is the best way I have seen to split the rows by categories

r_split <- c(rep(c("Fan"), 3),rep(c("Core-peripheral"), 2),"Complete",rep(c("Fan"),2),rep(c("Core-peripheral"), 4),
             rep(c("Asymmetric complete"), 2), "Complete", rep(c("Core-peripheral"), 3),rep(c("Asymmetric complete"), 2),
             "Complete", "Fan")

#set order of labels that avoids overlapping
r_split <- factor(r_split, levels=c("Core-peripheral","Complete","Fan","Asymmetric complete"))

#plat a bit with colors, a bit of a more complex set but looks nicer
library(circlize)
col_fun = colorRamp2(c(0.05644663,0.25, 0.4673256,0.75, 0.8782047), c("blue","cadetblue3", "azure2", "gold","red"))

h_pol <- Heatmap(long_m, name = "Mean\npercentile", row_split=r_split,cluster_row_slices = FALSE, 
        column_title = "Pollinator functional\ Groups",row_names_gp = gpar(fontsize = 12),col = col_fun)

 #Prepare plants

#long format
long_plants <- melt(setDT(heat_plants), id.vars = c("position","Broad_categories"), variable.name = "Functional_groups")

#filter for creating matrix
long_plants_1 <- long_plants %>% select(-Broad_categories)  


#set better colnames
long_plants_1$Functional_groups <- as.character(long_plants_1$Functional_groups)

long_plants_1$Functional_groups[long_plants_1$Functional_groups==1] <- "Cluster 1" 
long_plants_1$Functional_groups[long_plants_1$Functional_groups==2] <- "Cluster 2" 
long_plants_1$Functional_groups[long_plants_1$Functional_groups==3] <- "Cluster 3" 
long_plants_1$Functional_groups[long_plants_1$Functional_groups==4] <- "Cluster 4" 
long_plants_1$Functional_groups[long_plants_1$Functional_groups==5] <- "Cluster 5" 

long_plants_1$Functional_groups <- factor(long_plants_1$Functional_groups, levels=c("Cluster 1",
"Cluster 2" ,"Cluster 3","Cluster 4" ,"Cluster 5" ))

#create matrix with reshape
long_plants_m <- acast(long_plants_1, position~Functional_groups, value.var="value")

r_split_plants <- c(rep(c("Fan"), 3),rep(c("Core-peripheral"), 2),"Complete",rep(c("Fan"),2),rep(c("Core-peripheral"), 3),
             rep(c("Asymmetric complete"), 2), "Complete", rep(c("Core-peripheral"), 4),rep(c("Asymmetric complete"), 2),
             "Complete", "Fan")

r_split_plants <- factor(r_split, levels=c("Core-peripheral","Complete","Fan","Asymmetric complete"))


h_plan <- Heatmap(long_plants_m, name = "Mean\npercentile", row_split=r_split_plants,cluster_row_slices = FALSE, 
        column_title = "Plant functional\ Groups",row_names_gp = gpar(fontsize = 12),col = col_fun)

library(patchwork)
h_pol+h_plan


```
